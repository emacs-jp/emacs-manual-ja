@c =============================================================
@c = 元 翻 訳: 高汐一紀＠電気通信大学
@c = 加筆修正: 大木敦雄＠大塚.筑波大学 = 1998/11/25
@c = 20.4改訂: 大木敦雄＠大塚.筑波大学 = 1999/09/12
@c =============================================================
@c This is part of the Emacs manual.
@c Copyright (C) 1985, 86, 87, 93, 94, 95, 97, 2000, 2001
@c   Free Software Foundation, Inc.
@c See file emacs.texi for copying conditions.
@node Search, Fixit, Display, Top
@c @chapter Searching and Replacement
@chapter 探索と置換 @emph{(2004/03/27)}
@c @cindex searching
@c @cindex finding strings within text
@cindex 探索
@cindex テキスト内での文字列探索

@c   Like other editors, Emacs has commands for searching for occurrences of
@c a string.  The principal search command is unusual in that it is
@c @dfn{incremental}; it begins to search before you have finished typing the
@c search string.  There are also nonincremental search commands more like
@c those of other editors.
他のエディタと同様に、Emacsにも文字列を探索するコマンドがあります。
主な探索コマンドが@dfn{インクリメンタル}（incremental）であるという点で、
普通とは違います。
探索したい文字列全体を入力し終えなくても、探索を始めます。
他のエディタの探索コマンドのように、
インクリメンタルでない探索コマンドもあります。

@c   Besides the usual @code{replace-string} command that finds all
@c occurrences of one string and replaces them with another, Emacs has a
@c more flexible replacement command called @code{query-replace}, which
@c asks interactively which occurrences to replace.
指定した文字列の出現すべてを探し出して別の文字列に置換する、
普通の置換コマンド@code{replace-string}に加えて、
Emacsにはより柔軟な、
出現箇所をみつけるたびに置換するかどうか対話的に尋ねる
問い合わせ型置換コマンド@code{query-replace}もあります。

@menu
* Incremental Search::		Search happens as you type the string.
* Nonincremental Search::	Specify entire string and then search.
* Word Search::			Search for sequence of words.
* Regexp Search::		Search for match for a regexp.
* Regexps::			Syntax of regular expressions.
* Search Case::			To ignore case while searching, or not.
* Configuring Scrolling::	Scrolling within incremental search.
* Replace::			Search, and replace some or all matches.
* Other Repeating Search::	Operating on all matches for some regexp.
@end menu

@node Incremental Search, Nonincremental Search, Search, Search
@c @section Incremental Search
@section インクリメンタルサーチ @emph{(2004/03/26)}

@c @cindex incremental search
@cindex インクリメンタルサーチ
@c   An incremental search begins searching as soon as you type the first
@c character of the search string.  As you type in the search string, Emacs
@c shows you where the string (as you have typed it so far) would be
@c found.  When you have typed enough characters to identify the place you
@c want, you can stop.  Depending on what you plan to do next, you may or
@c may not need to terminate the search explicitly with @key{RET}.
インクリメンタルサーチでは、
探索文字列の最初の文字を打つとただちに探索を開始します。
探索文字列を入力するたびに、
Emacsは（それまでに入力した）文字列がどこでみつかるか表示します。
目的の箇所を特定するのに十分なだけの文字を打ってしまえば、
そこで終りにできます。
つぎに何をするかにもよりますが、
@key{RET}で探索を陽に終了する必要がある場合もあります。

@c WideCommands
@table @kbd
@item C-s
@c Incremental search forward (@code{isearch-forward}).
前向きにインクリメンタルサーチする（@code{isearch-forward}）。
@item C-r
@c Incremental search backward (@code{isearch-backward}).
後向きにインクリメンタルサーチする（@code{isearch-backward}）。
@end table

@kindex C-s
@findex isearch-forward
@c   @kbd{C-s} starts a forward incremental search.  It reads characters
@c from the keyboard, and moves point past the next occurrence of those
@c characters.  If you type @kbd{C-s} and then @kbd{F}, that puts the
@c cursor after the first @samp{F} (the first following the starting point, since
@c this is a forward search).  Then if you type an @kbd{O}, you will see
@c the cursor move just after the first @samp{FO} (the @samp{F} in that
@c @samp{FO} may or may not be the first @samp{F}).  After another
@c @kbd{O}, the cursor moves after the first @samp{FOO} after the place
@c where you started the search.  At each step, the buffer text that
@c matches the search string is highlighted, if the terminal can do that;
@c the current search string is always displayed in the echo area.
@kbd{C-s}は順方向へのインクリメンタルサーチを始めます。
@kbd{C-s}はキーボードから文字を読み取り、
打った文字が最初に現れる位置までカーソルを移動します。
たとえば、@kbd{C-s}に続けて@kbd{F}を打つと、
カーソルは最初に現れる@samp{F}の直後に移動します(順方向への検索なので続く文字の開始点になります)。
さらに@kbd{O}を打つと、カーソルは最初に現れる@samp{FO}の直後に移動します
(@samp{FO} の @samp{F} は最初の@samp{F}かもしれないし，違うかもしれない)。
さらに@kbd{O}を打つと、探索を開始した場所以降で最初に現れる
@samp{FOO}の直後にカーソルが移動します。
各段階において、反転表示できる端末では、
探索文字列に一致するバッファ内のテキストを強調表示します。
また、各段階において、エコー領域には現在の探索文字列がいつも表示されます。

@c   If you make a mistake in typing the search string, you can cancel
@c characters with @key{DEL}.  Each @key{DEL} cancels the last character of
@c search string.  This does not happen until Emacs is ready to read another
@c input character; first it must either find, or fail to find, the character
@c you want to erase.  If you do not want to wait for this to happen, use
@c @kbd{C-g} as described below.
探索する文字列を打ちまちがえたときには、@key{DEL}で取り消せます。
@key{DEL}を1回押すごとに、探索文字列の最後の文字を取り消していきます。
ただし、Emacsがつぎの入力文字を受け付け可能になるまで、
この取り消し操作は実行できません。
つまり、取り消そうと思っている文字をみつけるか、
もしくはみつけられなかったことが確定する必要があります。
それまで待てないなら、以下に説明するように@kbd{C-g}を使ってください。

@c   When you are satisfied with the place you have reached, you can type
@c @key{RET}, which stops searching, leaving the cursor where the search
@c brought it.  Also, any command not specially meaningful in searches
@c stops the searching and is then executed.  Thus, typing @kbd{C-a}
@c would exit the search and then move to the beginning of the line.
@c @key{RET} is necessary only if the next command you want to type is a
@c printing character, @key{DEL}, @key{RET}, or another character that is
@c special within searches (@kbd{C-q}, @kbd{C-w}, @kbd{C-r}, @kbd{C-s},
@c @kbd{C-y}, @kbd{M-y}, @kbd{M-r}, @kbd{M-s}, and some other
@c meta-characters).
目的の箇所まで移動できたら、@key{RET}を打ちます。
すると、探索を終了しカーソルはその箇所に留まります。
また、探索に関係ないコマンドを打っても、
探索を終了し、そのコマンドを実行します。
したがって、@kbd{C-a}と打てば、探索を終了し、カーソルを行頭に移動します。
@key{RET}が必要な場面は、
つぎに入力したいコマンドが、印字文字、@key{DEL}、@key{RET}、および、
探索で特別な意味を持つその他の各種コントロール文字
（@kbd{C-q}、@kbd{C-w}、@kbd{C-r}、@kbd{C-s}、
@kbd{C-y}、@kbd{M-y}、@kbd{M-r}、@kbd{M-s}）やいくつかのメタ文字である場合だけです。

@c   Sometimes you search for @samp{FOO} and find one, but not the one you
@c expected to find.  There was a second @samp{FOO} that you forgot
@c about, before the one you were aiming for.  In this event, type
@c another @kbd{C-s} to move to the next occurrence of the search string.
@c You can repeat this any number of times.  If you overshoot, you can
@c cancel some @kbd{C-s} characters with @key{DEL}.
@samp{FOO}を探してそれがみつかった場合でも、
予期していた@samp{FOO}ではないこともあるでしょう。
最初の@samp{FOO}以降に、2つめの@samp{FOO}があることを
忘れていたような場合です。
このようなときには、さらに@kbd{C-s}を打てば、
探索文字列のつぎの出現箇所に移動できます。
この操作は何度でも繰り返せます。
行き過ぎてしまったときには、@key{DEL}で@kbd{C-s}の操作を取り消せます。

@c   After you exit a search, you can search for the same string again by
@c typing just @kbd{C-s C-s}: the first @kbd{C-s} is the key that invokes
@c incremental search, and the second @kbd{C-s} means ``search again.''
探索を終了したあとでも、単に@kbd{C-s C-s}と打てば、
ふたたび同じ文字列を探索できます。
つまり、最初の@kbd{C-s}がインクリメンタルサーチを起動して、
つぎの@kbd{C-s}が『再探索』を意味します。

@c   To reuse earlier search strings, use the @dfn{search ring}.  The
@c commands @kbd{M-p} and @kbd{M-n} move through the ring to pick a search
@c string to reuse.  These commands leave the selected search ring element
@c in the minibuffer, where you can edit it.  Type @kbd{C-s} or @kbd{C-r}
@c to terminate editing the string and search for it.
以前に探索した文字列を再利用するには、
@dfn{探索リング}（search ring）を使います。
コマンド@kbd{M-p}と@kbd{M-n}でリング内を移動して、
再利用する文字列を取り出します。
これらのコマンドは、探索リング内の選択した要素をミニバッファに置きますから、
編集することも可能です。
@kbd{C-s}や@kbd{C-r}を打てば、
文字列の編集を終了して探索を開始できます。

@c   If your string is not found at all, the echo area says @samp{Failing
@c I-Search}.  The cursor is after the place where Emacs found as much of your
@c string as it could.  Thus, if you search for @samp{FOOT}, and there is no
@c @samp{FOOT}, you might see the cursor after the @samp{FOO} in @samp{FOOL}.
@c At this point there are several things you can do.  If your string was
@c mistyped, you can rub some of it out and correct it.  If you like the place
@c you have found, you can type @key{RET} or some other Emacs command to
@c remain there.  Or you can type @kbd{C-g}, which
@c removes from the search string the characters that could not be found (the
@c @samp{T} in @samp{FOOT}), leaving those that were found (the @samp{FOO} in
@c @samp{FOOT}).  A second @kbd{C-g} at that point cancels the search
@c entirely, returning point to where it was when the search started.
探している文字列がまったくみつからなかった場合には、
エコー領域に@samp{Failing I-Search}と表示されます。
カーソルは、指定した文字列に可能な限り一致する箇所の直後にあります。
たとえば、@samp{FOOT}を探索しようとしたのに@samp{FOOT}がなければ、
カーソルは@samp{FOOL}の@samp{FOO}の直後にあります。
この時点でできることはいくつかあります。
文字列を打ちまちがえたのならば、それを消去して訂正します。
その箇所でよいのなら、その場所に留まるために、
@key{RET}か他のEmacsコマンドを打ちます。
あるいは、@kbd{C-g}を打てば、
探索文字列からみつけられなかった文字（@samp{FOOT}中の@samp{T}）を取り除き、
みつけた文字列（@samp{FOOT}中の@samp{FOO}）は
そのままにしておくこともできます。
ここで、さらに@kbd{C-g}を打つと、
探索全体を取り止めて、探索を開始した位置に戻ります。

@c   An upper-case letter in the search string makes the search
@c case-sensitive.  If you delete the upper-case character from the search
@c string, it ceases to have this effect.  @xref{Search Case}.
探索文字列に大文字を指定すると、
大文字小文字を区別（case-sensitive）して探索します。
探索文字列から大文字を削除すると、この効果は消えます。
@xref{Search Case}。

@c   To search for a newline, type @kbd{C-j}.  To search for another
@c control character, such as control-S or carriage return, you must quote
@c it by typing @kbd{C-q} first.  This function of @kbd{C-q} is analogous
@c to its use for insertion (@pxref{Inserting Text}): it causes the
@c following character to be treated the way any ``ordinary'' character is
@c treated in the same context.  You can also specify a character by its
@c octal code: enter @kbd{C-q} followed by a sequence of octal digits.
改行を探索するには、@kbd{C-j}を打ちます。
コントロールSや改行などのコントロール文字を探索するには、
まず@kbd{C-q}を打ってクォートする必要があります。
@kbd{C-q}のこの機能は、挿入時の利用法に似ています
（@pxref{Inserting Text}）。
このコマンドは、あとに続く文字を、
同じ文脈における『普通の』文字と同様に扱うようにします。
文字を8進コードで指定することもできて、
@kbd{C-q}に続けて8進数字列を入力します。

@cindex searching for non-@acronym{ASCII} characters
@cindex input method, during incremental search
@c   To search for non-@acronym{ASCII} characters, you must use an input method
@c (@pxref{Input Methods}).  If an input method is enabled in the
@c current buffer when you start the search, you can use it while you
@c type the search string also.  Emacs indicates that by including the
@c input method mnemonic in its prompt, like this:
非@acronym{ASCII}文字を探索するためには，入力メソッド (@pxref{Input Methods}) を
使わなければなりません．探索を始める時に入力メソッドがオンになっていると，探索す
る時にも入力メソッドを利用できます．この時Emacs はプロンプトに以下のように入力メ
ソッドの略称を表示します．

@example
I-search [@var{im}]:
@end example

@noindent
@findex isearch-toggle-input-method
@findex isearch-toggle-specified-input-method
@c where @var{im} is the mnemonic of the active input method.  You can
@c toggle (enable or disable) the input method while you type the search
@c string with @kbd{C-\} (@code{isearch-toggle-input-method}).  You can
@c turn on a certain (non-default) input method with @kbd{C-^}
@c (@code{isearch-toggle-specified-input-method}), which prompts for the
@c name of the input method.  The input method you enable during
@c incremental search remains enabled in the current buffer afterwards.
@var{im}は入力メソッドの略称です．検索中に @kbd{C-\}
(@code{isearch-toggle-input-method}) を入力することで，入力メソッドをトグル(有効
か無効かを切り替え)できます．@kbd{C-^}
(@code{isearch-toggle-specified-input-method}) である(デフォルトでない)入力メソッ
ドを有効にし，プロンプトに入力メソッド名を表示します．検索中に有効にした入力メソッ
ドは検索を終了しカレントバッファに戻っても有効な状態のまま保たれます．

@c   If a search is failing and you ask to repeat it by typing another
@c @kbd{C-s}, it starts again from the beginning of the buffer.
@c Repeating a failing reverse search with @kbd{C-r} starts again from
@c the end.  This is called @dfn{wrapping around}, and @samp{Wrapped}
@c appears in the search prompt once this has happened.  If you keep on
@c going past the original starting point of the search, it changes to
@c @samp{Overwrapped}, which means that you are revisiting matches that
@c you have already seen.
探索に失敗したときに、さらに@kbd{C-s}を打って探索の続行を指示すると、
バッファの先頭からもう一度探索し始めます。
後向きの探索に失敗したときに再度@kbd{C-r}を打つと、
バッファの末尾から探索を再開します。
これらの操作は@dfn{巻き直し}（wrapping around）と呼ばれます。
巻き直しが起こると、探索のプロンプトには@samp{Wrapped}が表示されます。
もともとの探索開始位置を通過してなお探索を続けると、
表示が@samp{Overwrapped}に変わります。
これは、探索文字列にすでに一度一致した箇所を
再度探索していることを意味します。

@c @cindex quitting (in search)
@cindex 中断（探索）
@c   The @kbd{C-g} ``quit'' character does special things during searches;
@c just what it does depends on the status of the search.  If the search has
@c found what you specified and is waiting for input, @kbd{C-g} cancels the
@c entire search.  The cursor moves back to where you started the search.  If
@c @kbd{C-g} is typed when there are characters in the search string that have
@c not been found---because Emacs is still searching for them, or because it
@c has failed to find them---then the search string characters which have not
@c been found are discarded from the search string.  With them gone, the
@c search is now successful and waiting for more input, so a second @kbd{C-g}
@c will cancel the entire search.
『中断』文字@kbd{C-g}は、探索中には特別な意味があり、
その機能は探索の状態に依存します。
指定したものがみつかり入力待ちの状態にあると、
@kbd{C-g}は探索全体を取り消します。
カーソルは探索開始位置に戻ります。
Emacsが探索中であったり探索に失敗したために、
探索文字列内に未発見の文字がある場合に@kbd{C-g}を打つと、
探索文字列から未発見の文字を消去します。
そうすると、これで探索が成功したことになるので、
入力待ちになります。
続けて@kbd{C-g}を打つと、探索全体を取り消します。

@c   To search for a newline, type @kbd{C-j}.  To search for another
@c control character, such as control-S or carriage return, you must quote
@c it by typing @kbd{C-q} first.  This function of @kbd{C-q} is analogous
@c to its use for insertion (@pxref{Inserting Text}): it causes the
@c following character to be treated the way any ``ordinary'' character is
@c treated in the same context.  You can also specify a character by its
@c octal code: enter @kbd{C-q} followed by a sequence of octal digits.
改行を探索するには、@kbd{C-j}を打ちます。
コントロールSや改行などのコントロール文字を探索するには、
まず@kbd{C-q}を打ってクォートする必要があります。
@kbd{C-q}のこの機能は、挿入時の利用法に似ています
（@pxref{Inserting Text}）。
このコマンドは、あとに続く文字を、
同じ文脈における『普通の』文字と同様に扱うようにします。
文字を8進コードで指定することもできて、
@kbd{C-q}に続けて8進数字列を入力します。

@c   You can change to searching backwards with @kbd{C-r}.  If a search fails
@c because the place you started was too late in the file, you should do this.
@c Repeated @kbd{C-r} keeps looking for more occurrences backwards.  A
@c @kbd{C-s} starts going forwards again.  @kbd{C-r} in a search can be canceled
@c with @key{DEL}.
@kbd{C-r}を使えば、後向き探索に変更できます。
ファイルのうしろのほうで探索し始めたために探索に失敗したのであれば、
これを試してください。
@kbd{C-r}を繰り返し打つと、後向きにさらに探索を続けます。
@kbd{C-s}は、ふたたび前向き探索を再開します。
探索中の@kbd{C-r}は@key{DEL}で取り消せます。

@kindex C-r
@findex isearch-backward
@c   If you know initially that you want to search backwards, you can use
@c @kbd{C-r} instead of @kbd{C-s} to start the search, because @kbd{C-r} as
@c a key runs a command (@code{isearch-backward}) to search backward.  A
@c backward search finds matches that are entirely before the starting
@c point, just as a forward search finds matches that begin after it.
始めから後向きで探索するのであれば、
@kbd{C-s}のかわりに@kbd{C-r}を使って探索を始めます。
@kbd{C-r}は、後向きに探索するコマンド@code{isearch-backward}を起動します。
前向き探索が開始位置よりうしろにある一致箇所をみつけるのと同様に、
後向き探索は開始位置よりまえにある一致箇所をみつけだします。

@c   The characters @kbd{C-y} and @kbd{C-w} can be used in incremental
@c search to grab text from the buffer into the search string.  This
@c makes it convenient to search for another occurrence of text at point.
@c @kbd{C-w} copies the character or word after point as part of the
@c search string, advancing point over it.  (The decision, whether to
@c copy a character or a word, is heuristic.)  Another @kbd{C-s} to
@c repeat the search will then search for a string including that
@c character or word.
インクリメンタルサーチ中には、文字@kbd{C-y}と@kbd{C-w}を使って、
バッファから探索文字列へテキストを取り込むことができます。
この機能は、ポイント位置にあるテキストの出現箇所を探すときに便利です。
@kbd{C-w}は、ポイント以降の文字や単語を探索文字列の一部としてコピーし、
ポイントをその単語の末尾に進めます(文字か単語かは状況によって変わります)。
探索を繰り返す意味で@kbd{C-s}を打つと、
その文字や単語を含んだ文字列を探索します。
@kbd{C-y}も@kbd{C-w}に似ていますが、
現在行の残りの部分をすべて探索文字列にコピーします。
大文字小文字を区別しない探索では、
@kbd{C-y}と@kbd{C-w}はともに、
コピーするテキストを小文字だけに変換します。

@c   The character @kbd{M-y} copies text from the kill ring into the search
@c string.  It uses the same text that @kbd{C-y} as a command would yank.
@kbd{Mouse-2} in the echo area does the same.
@xref{Yanking}.
文字@kbd{M-y}は、キルリングから探索文字列にテキストをコピーします。
これには、ヤンクコマンド@kbd{C-y}がヤンクするのと
同じテキストを用います。エコー領域で @kbd{Mouse-2} としても同様のことができます．
@xref{Yanking}。

@c   When you exit the incremental search, it sets the mark to where point
@c @emph{was}, before the search.  That is convenient for moving back
@c there.  In Transient Mark mode, incremental search sets the mark without
@c activating it, and does so only if the mark is not already active.
インクリメンタルサーチを終了すると、
探索開始前にポイントが@emph{あった}位置にマークを置きます。
これにより容易にその位置に戻れます。
暫定マーク（transient-mark）モードでは、
マークが不活性のときに限って、
インクリメンタルサーチが設定するマークも不活性です。

@cindex lazy search highlighting
@vindex isearch-lazy-highlight
@c   When you pause for a little while during incremental search, it
@c highlights all other possible matches for the search string.  This
@c makes it easier to anticipate where you can get to by typing @kbd{C-s}
@c or @kbd{C-r} to repeat the search.  The short delay before highlighting
@c other matches helps indicate which match is the current one.
@c If you don't like this feature, you can turn it off by setting
@c @code{isearch-lazy-highlight} to @code{nil}.
インクリメンタルサーチ中に少し中断すると，一致するすべての候補が強調表示されます．
これにより，次に @kbd{C-s} や @kbd{C-r} をした時にどこに移動するかが分かります．
強調表示するまでに多少遅れがありますので，現在の一致箇所もすぐに分かります．この
ような遅れが無い方がいい場合には @code{isearch-lazy-highlight} を @code{nil} に
設定します．

@vindex isearch-lazy-highlight-face
@cindex faces for highlighting search matches
@c   You can control how this highlighting looks by customizing the faces
@c @code{isearch} (used for the current match) and
@c @code{isearch-lazy-highlight-face} (for all the other matches).
通常の一致箇所のフェイスは @code{isearch}，その他のすべての一致箇所に使われるフェ
イスは @code{isearch-lazy-highlight-face} でカスタマイズできます．

@vindex isearch-mode-map
@c   To customize the special characters that incremental search understands,
@c alter their bindings in the keymap @code{isearch-mode-map}.  For a list
@c of bindings, look at the documentation of @code{isearch-mode} with
@c @kbd{C-h f isearch-mode @key{RET}}.
インクリメンタルサーチ中に用いる特別な文字をカスタマイズするには、
キーマップ@code{isearch-mode-map}中のバインディングを変更します。
バインディング一覧は、@kbd{C-h f isearch-mode @key{RET}}を使って
@code{isearch-mode}に関する説明文を参照してください。

@c @subsection Scrolling During Incremental Search
@subsection インクリメンタルサーチ中のスクロール @emph{(2004/03/25)}

@c   Vertical scrolling during incremental search can be enabled by
@c setting the customizable variable @code{isearch-allow-scroll} to a
@c non-nil value.
@code{isearch-allow-scroll} を non-nil に設定することでインクリメンタルサーチ中
にスクロールできるようになります．

@c   You can then use the vertical scroll-bar or certain keyboard
@c commands such as @kbd{@key{PRIOR}} (@code{scroll-down}),
@c @kbd{@key{NEXT}} (@code{scroll-up}) and @kbd{C-l} (@code{recenter})
@c within the search, thus letting you see more of the text near the
@c current match.  You must run these commands via their key sequences to
@c stay in the search - typing M-x @var{comand-name} will always
@c terminate a search.
検索中に縦方向のスクロールバーや @kbd{@key{PRIOR}} (@code{scroll-down}) や
@kbd{@key{NEXT}} (@code{scroll-up})，@kbd{C-l} (@code{recenter}) といった一部の
キーバインドを利用できるようになります．これにより，現在の一致箇所付近でもっと広
い箇所を見ることができます．ただし，検索を中断させないためにはこれらのキーバイン
ドを使わないといけません．M-x @var{comand-name} を使うと必ず検索を中断します．

@c   You can give prefix arguments to these commands in the usual way.
@c The current match cannot be scrolled out of the window - this is
@c intentional.
通常の方法で前置引数を与えることができます．現在の一致箇所がウィンドウ外になるよ
うなスクロールはできません．

@c   Several other commands, such as @kbd{C-x 2}
@c (@code{split-window-vertically}) and @kbd{C-x ^}
@c (@code{enlarge-window}) which don't scroll the window, are
@c nevertheless made available under this rubric, since they are likewise
@c handy during a search.
@kbd{C-x 2} (@code{split-window-vertically}) や @kbd{C-x ^}
(@code{enlarge-window}) のようなコマンドはウィンドウはスクロールさせません．しか
し，検索中に利用できると便利なため，これらのコマンドも検索中に利用できます．

@c   For a list of commands which are configured as scrolling commands by
@c default and instructions on how thus to configure other commands, see
@c @ref{Configuring Scrolling}.
デフォルトでスクロールさせるコマンド(検索中に利用できるコマンド)として設定されて
いるものの一覧や他のコマンドを設定する方法は @ref{Configuring Scrolling} を参照
ください．

@c @subsection Slow Terminal Incremental Search
@subsection 低速端末でのインクリメンタルサーチ @emph{(2004/03/26)}

@c   Incremental search on a slow terminal uses a modified style of display
@c that is designed to take less time.  Instead of redisplaying the buffer at
@c each place the search gets to, it creates a new single-line window and uses
@c that to display the line that the search has found.  The single-line window
@c comes into play as soon as point moves outside of the text that is already
@c on the screen.
速度の遅い端末でのインクリメンタルサーチでは、
表示時間が少なくてすむように設計された表示形式を使います。
みつけた箇所でバッファを再表示するかわりに、
新たに1行分のウィンドウを作ってそこにみつけた行を表示します。
この1行分のウィンドウは、
探索することでポイントが画面に表示中のテキストから
飛び出た時点で使われます。

@c   When you terminate the search, the single-line window is removed.
@c Emacs then redisplays the window in which the search was done, to show
@c its new position of point.
探索を終了すると、この1行分のウィンドウは消えます。
そして、Emacsは探索を完了したウィンドウを再表示して、
新たなポイント位置を示します。

@ignore
@c   The three dots at the end of the search string, normally used to indicate
@c that searching is going on, are not displayed in slow style display.
探索中であることを示すために探索文字列の末尾に3つの点
（@dots{}）を通常表示しますが、低速向けの表示形式では表示しません。
@end ignore

@vindex search-slow-speed
@c   The slow terminal style of display is used when the terminal baud rate is
@c less than or equal to the value of the variable @code{search-slow-speed},
@c initially 1200.  See @code{baud-rate} in @ref{Display Custom}.
低速向けの表示形式を使うのは、
端末のボーレートが変数@code{search-slow-speed}の値以下である場合で、
その初期値は1200です。@ref{Display Custom} の @code{baud-rate} を参照ください．

@vindex search-slow-window-lines
@c   The number of lines to use in slow terminal search display is controlled
@c by the variable @code{search-slow-window-lines}.  Its normal value is 1.
低速向けの表示形式に使う表示用ウィンドウの行数は、
変数@code{search-slow-window-lines}で制御します。
通常の値は1です。

@node Nonincremental Search, Word Search, Incremental Search, Search
@c @section Nonincremental Search
@section 一括型探索
@c @cindex nonincremental search
@cindex 一括型探索

@c   Emacs also has conventional nonincremental search commands, which require
@c you to type the entire search string before searching begins.
Emacsでは、従来方式の一括型探索コマンドもあります。
探索を開始するまえに探索文字列全体を打っておく必要があります。

@table @kbd
@item C-s @key{RET} @var{string} @key{RET}
@c Search for @var{string}.
@var{string}を探索する。
@item C-r @key{RET} @var{string} @key{RET}
@c Search backward for @var{string}.
@var{string}を後向きに探索する。
@end table

@c   To do a nonincremental search, first type @kbd{C-s @key{RET}}.  This
@c enters the minibuffer to read the search string; terminate the string
@c with @key{RET}, and then the search takes place.  If the string is not
@c found, the search command signals an error.
一括型探索を実行するには、まず@kbd{C-s @key{RET}}と打ちます。
すると、探索文字列を読み取るためにミニバッファに移動します。
文字列を@key{RET}で終えると、探索を開始します。
文字列がみつからなければ、探索コマンドはエラーを表示します。

@c   When you type @kbd{C-s @key{RET}}, the @kbd{C-s} invokes incremental
@c search as usual.  That command is specially programmed to invoke
@c nonincremental search, @code{search-forward}, if the string you
@c specify is empty.  (Such an empty argument would otherwise be
@c useless.)  But it does not call @code{search-forward} right away.  First
@c it checks the next input character to see if is @kbd{C-w},
@c which specifies a word search.
@kbd{C-s @key{RET}} はつぎのように動作します。
まず、@kbd{C-s}がいつものようにインクリメンタルサーチを起動します。
インクリメンタルサーチは、特別な場合として、
引数が空であったときには一括型探索(@code{search-forward})を起動するようにプログラムしてあります。
（さもなければ、そのような空の引数に意味はない）．
しかし、@kbd{C-s @key{RET}}で実行される一括型探索は、
@code{search-forward}をただちに呼び出すわけではありません。
まず、つぎの文字が単語探索を指示する@kbd{C-w}であるかどうか調べます。
@ifinfo
@c @xref{Word Search}.
@xref{Word Search}。
@end ifinfo
@c @kbd{C-r @key{RET}} does likewise, for a reverse incremental search.
@kbd{C-r @key{RET}} も逆方向のインクリメンタルサーチとして同様に機能し
ます．

@findex search-forward
@findex search-backward
@c   Forward and backward nonincremental searches are implemented by the
@c commands @code{search-forward} and @code{search-backward}.  These
@c commands may be bound to keys in the usual manner.  The feature that you
@c can get to them via the incremental search commands exists for
@c historical reasons, and to avoid the need to find key sequences
@c for them.
前向き／後向きの一括型探索は、
コマンド@code{search-forward}と@code{search-backward}で実装されています。
これらのコマンドは通常と同じようにキーにバインドできます。
インクリメンタルサーチコマンドから呼び出せるようになっているのは、
歴史的な理由、および、
キー列を選ぶ労力を削減できるという理由からです。

@node Word Search, Regexp Search, Nonincremental Search, Search
@c @section Word Search
@section 単語探索
@c @cindex word search
@cindex 単語探索

@c   Word search searches for a sequence of words without regard to how the
@c words are separated.  More precisely, you type a string of many words,
@c using single spaces to separate them, and the string can be found even
@c if there are multiple spaces, newlines, or other punctuation characters
@c between these words.
単語探索は、単語の区切られ方を無視して、単語の列を探索します。
より正確には、空白1個で区切った数個の単語を打ち込むと、
単語と単語のあいだに複数個の空白／改行／句読点があったとしても、
それらの文字列をみつけだすことができます。

@c   Word search is useful for editing a printed document made with a text
@c formatter.  If you edit while looking at the printed, formatted version,
@c you can't tell where the line breaks are in the source file.  With word
@c search, you can search without having to know them.
単語探索は、テキスト清書系で整形済みの文書を編集する場合に便利です。
整形した印刷出力を見ながら編集する場合、
ソースファイルのどこで行が区切られているのかわかりません。
単語探索を使えば、単語の区切られ方を知らなくても探索できます。

@table @kbd
@item C-s @key{RET} C-w @var{words} @key{RET}
@c Search for @var{words}, ignoring details of punctuation.
句読点などの詳細は無視して、@var{words}を探索する。
@item C-r @key{RET} C-w @var{words} @key{RET}
@c Search backward for @var{words}, ignoring details of punctuation.
句読点などの詳細は無視して、後向きに@var{words}を探索する。
@end table

@c   Word search is a special case of nonincremental search and is invoked
@c with @kbd{C-s @key{RET} C-w}.  This is followed by the search string,
@c which must always be terminated with @key{RET}.  Being nonincremental,
@c this search does not start until the argument is terminated.  It works
@c by constructing a regular expression and searching for that; see
@c @ref{Regexp Search}.
単語探索は、一括型探索の特別な場合であって、
@kbd{C-s @key{RET} C-w}で起動します。
この入力に続いて、探索文字列を入力し、
文字列はつねに@key{RET}で終えます。
一括型であるため、単語探索も引数を入力し終えるまで探索を開始しません。
単語探索は、正規表現を構築し、その正規表現で探索を行うことで
動作します。
@xref{Regexp Search}。

@c   Use @kbd{C-r @key{RET} C-w} to do backward word search.
後向きの単語探索には@kbd{C-r @key{RET} C-w}を使います。

@findex word-search-forward
@findex word-search-backward
@c   Forward and backward word searches are implemented by the commands
@c @code{word-search-forward} and @code{word-search-backward}.  These
@c commands may be bound to keys in the usual manner.  They are available
@c via the incremental search commands both for historical reasons and
@c to avoid the need to find suitable key sequences for them.
前向き／後向きの単語探索は、それぞれ、
コマンド@code{word-search-forward}と@code{word-search-backward}で
実装されています。
これらのコマンドは通常どおりキーに割り当てることができます。
インクリメンタルサーチコマンドから呼び出せるようになっているのは、
歴史的な理由、および、
これらの機能にふさわしいキー列を選ぶ労力を削減できるという理由からです。

@node Regexp Search, Regexps, Word Search, Search
@c @section Regular Expression Search
@section 正規表現探索
@c @cindex regular expression
@cindex 正規表現
@cindex regexp

@c   A @dfn{regular expression} (@dfn{regexp}, for short) is a pattern
@c that denotes a class of alternative strings to match, possibly
@c infinitely many.  GNU Emacs provides both incremental and
@c nonincremental ways to search for a match for a regexp.
@dfn{正規表現}（regular expression、@dfn{regexp}と略す）とは、
一致する可能性がある一連の（無限個でもよい）文字列を表現するパターンです。
GNU Emacsでは、インクリメンタルサーチでも一括型探索でも、
正規表現を用いた探索ができます。

@kindex C-M-s
@findex isearch-forward-regexp
@kindex C-M-r
@findex isearch-backward-regexp
@c   Incremental search for a regexp is done by typing @kbd{C-M-s}
@c (@code{isearch-forward-regexp}), or by invoking @kbd{C-s} with a
@c prefix argument (whose value does not matter).  This command reads a
@c search string incrementally just like @kbd{C-s}, but it treats the
@c search string as a regexp rather than looking for an exact match
@c against the text in the buffer.  Each time you add text to the search
@c string, you make the regexp longer, and the new regexp is searched
@c for.  To search backward for a regexp, use @kbd{C-M-r}
@c (@code{isearch-backward-regexp}), or @kbd{C-r} with a prefix argument.
正規表現によるインクリメンタルサーチを実行するには、
@kbd{C-M-s}（@code{isearch-forward-regexp}）と打つか，（値は関係ない）
前置引数を指定して@kbd{C-s}を起動します。
このコマンドは、@kbd{C-s}と同様に、探索文字列を逐次読み取ります。
ただし、探索文字列をバッファのテキストに対して正確に照合するため
のものとみなすのではなく、正規表現として扱います。
探索文字列にテキストを追加するごとに、
正規表現は長くなり、新たな正規表現を探索します。
後向きに正規表現を探索するには、
@kbd{C-M-r}（@code{isearch-backward-regexp}）を使うか、
前置引数を指定して@kbd{C-r}を使います。

@c   All of the control characters that do special things within an
@c ordinary incremental search have the same function in incremental regexp
@c search.  Typing @kbd{C-s} or @kbd{C-r} immediately after starting the
@c search retrieves the last incremental search regexp used; that is to
@c say, incremental regexp and non-regexp searches have independent
@c defaults.  They also have separate search rings that you can access with
@c @kbd{M-p} and @kbd{M-n}.
通常のインクリメンタルサーチにおいて特別な機能を持つコントロール文字は、
正規表現のインクリメンタルサーチでも同じ機能を持ちます。
探索の開始直後に@kbd{C-s}や@kbd{C-r}を打つと、
最後のインクリメンタルサーチに用いた正規表現を再度使います。
つまり、正規表現を用いる探索とそうでない探索とには、
それぞれ独立のデフォルトがあるのです。
@kbd{M-p}と@kbd{M-n}で参照できる探索リングも
それぞれ別々です。

@c   If you type @key{SPC} in incremental regexp search, it matches any
@c sequence of whitespace characters, including newlines.  If you want
@c to match just a space, type @kbd{C-q @key{SPC}}.
正規表現のインクリメンタルサーチで@key{SPC}を打つと、
改行を含めた任意個の白文字に一致します。
ちょうど1個の空白に一致させたいのであれば、
@kbd{C-q @key{SPC}}と打ちます。

@c   Note that adding characters to the regexp in an incremental regexp
@c search can make the cursor move back and start again.  For example, if
@c you have searched for @samp{foo} and you add @samp{\|bar}, the cursor
@c backs up in case the first @samp{bar} precedes the first @samp{foo}.
正規表現のインクリメンタルサーチ中に正規表現に文字を加えると、
カーソルをもとに戻して探索し直すことがあります。
たとえば、@samp{foo}を探索し終えたときに@samp{\|bar}を追加したとします。
最初の@samp{bar}が最初の@samp{foo}に先行する場合には、
カーソルはまえに戻ります。

@findex re-search-forward
@findex re-search-backward
@c   Nonincremental search for a regexp is done by the functions
@c @code{re-search-forward} and @code{re-search-backward}.  You can invoke
@c these with @kbd{M-x}, or bind them to keys, or invoke them by way of
@c incremental regexp search with @kbd{C-M-s @key{RET}} and @kbd{C-M-r
@c @key{RET}}.
正規表現の一括型探索は、関数@code{re-search-forward}と
@code{re-search-backward}で行われます。
これらは、@kbd{M-x}で呼び出したり、キーに割り当てたり、あるいは、
@kbd{C-M-s @key{RET}}や@kbd{C-M-r @key{RET}}として
正規表現のインクリメンタルサーチの方法で起動したりできます。

@c   If you use the incremental regexp search commands with a prefix
@c argument, they perform ordinary string search, like
@c @code{isearch-forward} and @code{isearch-backward}.  @xref{Incremental
@c Search}.
正規表現のインクリメンタルサーチコマンドに前置引数を指定すると、
@code{isearch-forward}や@code{isearch-backward}のように、
普通の文字列探索を行います。
@xref{Incremental  Search}。

@node Regexps, Search Case, Regexp Search, Search
@c @section Syntax of Regular Expressions
@section 正規表現の構文 @emph{(2004/03/26)}
@c @cindex syntax of regexps
@cindex regexpの構文

@c   This manual describes regular expression features that users
@c typically want to use.  There are additional features that are
@c mainly used in Lisp programs; see @ref{Regular Expressions,,,
@c elisp, the same manual}.
このマニュアルではよく使われる正規表現について説明しています．主にリス
プのプログラムで使われる追加機能については @ref{Regular
Expressions,,,elisp, the same manual} を参照してください．

@c   Regular expressions have a syntax in which a few characters are
@c special constructs and the rest are @dfn{ordinary}.  An ordinary
@c character is a simple regular expression which matches that same
@c character and nothing else.  The special characters are @samp{$},
@c @samp{^}, @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, @samp{]} and
@c @samp{\}.  Any other character appearing in a regular expression is
@c ordinary, unless a @samp{\} precedes it.  (When you use regular
@c expressions in a Lisp program, each @samp{\} must be doubled, see the
@c example near the end of this section.)
正規表現には、特別な使い方をする少数の文字と
その他の@dfn{普通の}文字から成る構文があります。
普通の文字は、
同じ文字だけに一致してそれ以外には一致しない単純な正規表現です。
特別な文字は、@samp{$}、@samp{^}、@samp{.}、@samp{*}、@samp{+}、
@samp{?}、@samp{[}、@samp{]}、および、@samp{\}です。
@samp{\}が先行する場合を除いて、
正規表現に現れるこれら以外の文字は普通の文字です(正規表現をリスプコー
ド内で使う場合には @samp{\} が倍必要になります．具体的には，この章の終わりにあるサ
ンプルを参照してください)。

@c   For example, @samp{f} is not a special character, so it is ordinary, and
@c therefore @samp{f} is a regular expression that matches the string
@c @samp{f} and no other string.  (It does @emph{not} match the string
@c @samp{ff}.)  Likewise, @samp{o} is a regular expression that matches
@c only @samp{o}.  (When case distinctions are being ignored, these regexps
@c also match @samp{F} and @samp{O}, but we consider this a generalization
@c of ``the same string,'' rather than an exception.)
たとえば、@samp{f}は特別な文字ではなく、通常の文字ですから、
文字列@samp{f}に一致してそれ以外の文字列には一致しない正規表現です。
（これは、文字列@samp{ff}には一致し@emph{ない}。）
同様に、@samp{o}は、@samp{o}だけに一致する正規表現です。
（大文字小文字を区別しない場合、
これらの正規表現は@samp{F}や@samp{O}にも一致するが、
これらは例外というよりは、『同じ文字列』の一般化として捉える。）

@c   Any two regular expressions @var{a} and @var{b} can be concatenated.  The
@c result is a regular expression which matches a string if @var{a} matches
@c some amount of the beginning of that string and @var{b} matches the rest of
@c the string.@refill
任意の2つの正規表現@var{a}と@var{b}を連結できます。
その結果は、@var{a}が文字列の始めの適当な部分に一致して、かつ、
@var{b}が文字列の残りの部分に一致する場合に、
文字列に一致するような正規表現です。

@c   As a simple example, we can concatenate the regular expressions @samp{f}
@c and @samp{o} to get the regular expression @samp{fo}, which matches only
@c the string @samp{fo}.  Still trivial.  To do something nontrivial, you
@c need to use one of the special characters.  Here is a list of them.
簡単な例として、正規表現@samp{f}と@samp{o}を連結すると、
正規表現@samp{fo}を得ますが、
これは文字列@samp{fo}だけに一致します。
簡単ですね。
多少とも複雑なことを行うには、特別な文字を使う必要があります。
以下にその一覧をあげます。

@table @asis
@c @item @kbd{.}@: @r{(Period)}
@item @kbd{.}@: @r{(ピリオド)}
@c is a special character that matches any single character except a newline.
@c Using concatenation, we can make regular expressions like @samp{a.b}, which
@c matches any three-character string that begins with @samp{a} and ends with
@c @samp{b}.@refill
特別な文字であり、改行以外の任意の1文字に一致する。
連結を使って@samp{a.b}のような正規表現を作れる。
これは、@samp{a}で始まり@samp{b}で終る任意の3文字の文字列に一致する。

@item @kbd{*}
@c is not a construct by itself; it is a postfix operator that means to
@c match the preceding regular expression repetitively as many times as
@c possible.  Thus, @samp{o*} matches any number of @samp{o}s (including no
@c @samp{o}s).
単独では構成要素ではない。
直前の正規表現を可能な限り反復することを意味する後置演算子である。
すなわち、（@samp{o}が存在しない場合も含めて）
@samp{o*}は任意個の@samp{o}に一致する。

@c @samp{*} always applies to the @emph{smallest} possible preceding
@c expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating
@c @samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on.
@samp{*}はつねに先行する@emph{最小}の正規表現に適用される。
したがって、@samp{fo*}は@samp{fo}を繰り返すのではなく、
@samp{o}を繰り返す。
この正規表現は@samp{f}、@samp{fo}、@samp{foo}などに一致する。

@c The matcher processes a @samp{*} construct by matching, immediately,
@c as many repetitions as can be found.  Then it continues with the rest
@c of the pattern.  If that fails, backtracking occurs, discarding some
@c of the matches of the @samp{*}-modified construct in case that makes
@c it possible to match the rest of the pattern.  For example, in matching
@c @samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first
@c tries to match all three @samp{a}s; but the rest of the pattern is
@c @samp{ar} and there is only @samp{r} left to match, so this try fails.
@c The next alternative is for @samp{a*} to match only two @samp{a}s.
@c With this choice, the rest of the regexp matches successfully.@refill
@samp{*}を用いた構成は、一致を処理するときには、
ただちに得られる限りの反復回数に展開される。
そうしてから、残りのパターンを処理する。
一致に失敗すると、バックトラック（後戻り）が発生して、
@samp{*}を用いた構成の反復回数を減らして、
パターンの残りの部分が一致するようにする。
たとえば、文字列@samp{caaar}に対して
@samp{ca*ar}を一致させることを考えてみる。
始めに、@samp{a*}を3つの@samp{a}すべてに一致させようとする。
しかし、残りのパターンが@samp{ar}なのに@samp{r}しか残っていないため、
この試みは失敗する。
そこで、つぎは@samp{a*}を@samp{a}2つだけに一致させる。
こうすると、残りの正規表現も正しく一致する。

@item @kbd{+}
@c is a postfix operator, similar to @samp{*} except that it must match
@c the preceding expression at least once.  So, for example, @samp{ca+r}
@c matches the strings @samp{car} and @samp{caaaar} but not the string
@c @samp{cr}, whereas @samp{ca*r} matches all three strings.
@samp{*}に似た後置演算子だが、
直前の正規表現に1回以上一致する必要がある。
たとえば、@samp{ca+r}は、文字列@samp{car}や@samp{caaaar}には一致するが、
文字列@samp{cr}には一致ない。
@samp{ca*r}の場合は、上記の3つすべてに一致する。

@item @kbd{?}
@c is a postfix operator, similar to @samp{*} except that it can match the
@c preceding expression either once or not at all.  For example,
@c @samp{ca?r} matches @samp{car} or @samp{cr}; nothing else.
@samp{*}に似た後置演算子だが、
直前の正規表現に1回だけ一致するか、あるいは、1回も一致しない。
たとえば、@samp{ca?r}は、@samp{car}や@samp{cr}に一致するが、
他のものには一致しない。

@item @kbd{*?}, @kbd{+?}, @kbd{??}
@cindex non-greedy regexp matching
@c are non-greedy variants of the operators above.  The normal operators
@c @samp{*}, @samp{+}, @samp{?} are @dfn{greedy} in that they match as
@c much as they can, as long as the overall regexp can still match.  With
@c a following @samp{?}, they are non-greedy: they will match as little
@c as possible.
上記は最小一致の(non-greedy，貪欲でない)演算子である．@samp{*},
@samp{+}, @samp{?} のような普通の演算子は @dfn{greedy} (貪欲，最長一致)
である．つまり，正規表現に対してできる限り長い文字が一致する．@samp{?}
を付加すると貪欲でない最小一致にになるので，最小の部分が一致する．

@c Thus, both @samp{ab*} and @samp{ab*?} can match the string @samp{a}
@c and the string @samp{abbbb}; but if you try to match them both against
@c the text @samp{abbb}, @samp{ab*} will match it all (the longest valid
@c match), while @samp{ab*?}  will match just @samp{a} (the shortest
@c valid match).
つまり，@samp{ab*} と @samp{ab*?} は両方とも @samp{a} に一致するし，
@samp{abbbb} にも一致できる．しかし，@samp{abbbb} に対して両者の正規表
現をためしてみると，@samp{ab*}ではすべての部分(最長一致)が一致するのに
対して，@samp{ab*?} では @samp{a} だけ(最小一致)が一致する．

@c Non-greedy operators match the shortest possible string starting at a
@c given starting point; in a forward search, though, the earliest
@c possible starting point for match is always the one chosen.  Thus, if
@c you search for @samp{a.*?$} against the text @samp{abbab} followed by
@c a newline, it matches the whole string.  Since it @emph{can} match
@c starting at the first @samp{a}, it does.
最小一致の演算子は開始点以降でできる限り短い部分に一致するように検索を
行う．順方向の検索では一致する最も近い位置は常にカーソルの場所である．
それゆえ，@samp{a.*?$} を 改行に続く @samp{abbab} に対して検索すると全
体に一致する．最初の@samp{a}に一致するので，これが可能になる．

@item @kbd{\@{@var{n}\@}}
@c is a postfix operator that specifies repetition @var{n} times---that
@c is, the preceding regular expression must match exactly @var{n} times
@c in a row.  For example, @samp{x\@{4\@}} matches the string @samp{xxxx}
@c and nothing else.
は @var{n} 回の繰り返しを表す後置演算子である．つまり，後に続く正規表現をちょう
ど @var{n} 回繰り返す文字に一致する．例えば，@samp{x\@{4\@}} は @samp{xxxx} に一
致する．

@item @kbd{\@{@var{n},@var{m}\@}}
@c is a postfix operator that specifies repetition between @var{n} and
@c @var{m} times---that is, the preceding regular expression must match
@c at least @var{n} times, but no more than @var{m} times.  If @var{m} is
@c omitted, then there is no upper limit, but the preceding regular
@c expression must match at least @var{n} times.@* @samp{\@{0,1\@}} is
@c equivalent to @samp{?}. @* @samp{\@{0,\@}} is equivalent to
@c @samp{*}. @* @samp{\@{1,\@}} is equivalent to @samp{+}.
は後置的な演算子である．@var{n} 〜 @var{m} 回繰り返すことを意味する．
つまり，すくなくとも @var{n} 回は正規表現が一致しなければならず，
@var{m} 回を超えてもいけない．もし @var{m} を指定しなければ，上限が無
くなるが，すくなくとも @var{n} 回は一致しなければならない．@*
@samp{\@{0,1\@}} は @samp{?} と同じである．@* @samp{\@{0,\@}} は
@samp{*} と同じである．@* @samp{\@{1,\@}} は @samp{+} と同じになる．

@item @kbd{[ @dots{} ]}
@c is a @dfn{character set}, which begins with @samp{[} and is terminated
@c by @samp{]}.  In the simplest case, the characters between the two
@c brackets are what this set can match.
@samp{[}で始まり@samp{]}で終る@dfn{文字集合}を表す。
もっとも単純な場合は、
この2つの中括弧のあいだにある文字の1つ1つがこの文字集合に一致する。

@c Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and
@c @samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s
@c (including the empty string), from which it follows that @samp{c[ad]*r}
@c matches @samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc.
したがって、@samp{[ad]}は、@samp{a}1文字か@samp{d}1文字のどちらにも一致する。
@samp{[ad]*}は、@samp{a}と@samp{d}だけから成る
（空の文字列を含む）任意の文字列に一致する。
このことから、@samp{c[ad]*r}は、
@samp{cr}、@samp{car}、@samp{cdr}、@samp{caddaar}などに一致することがわかる。

@c You can also include character ranges in a character set, by writing the
@c starting and ending characters with a @samp{-} between them.  Thus,
@c @samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be
@c intermixed freely with individual characters, as in @samp{[a-z$%.]},
@c which matches any lower-case @acronym{ASCII} letter or @samp{$}, @samp{%} or
@c period.
文字集合には、文字範囲の指定を含めることもでき、
始めの文字と終りの文字のあいだに@samp{-}を書く。
つまり、@samp{[a-z]}はすべての @acronym{ASCII} 小文字に一致する。
範囲指定と個々の文字を自由に織り混ぜてよく、
@samp{[a-z$%.]}のように書ける。
これは、任意の @acronym{ASCII} の小文字、@samp{$}、@samp{%}、ピリオドに一致する。

@c Note that the usual regexp special characters are not special inside a
@c character set.  A completely different set of special characters exists
@c inside character sets: @samp{]}, @samp{-} and @samp{^}.
文字集合の内側では、正規表現の通常の特別な文字を
特別扱いしないことに注意。
文字集合の内側では、まったく別の特別な文字、
@samp{]}、@samp{-}、および @samp{^} が存在する。

@c To include a @samp{]} in a character set, you must make it the first
@c character.  For example, @samp{[]a]} matches @samp{]} or @samp{a}.  To
@c include a @samp{-}, write @samp{-} as the first or last character of the
@c set, or put it after a range.  Thus, @samp{[]-]} matches both @samp{]}
@c and @samp{-}.
文字集合に@samp{]}を含めるには、
@samp{]}を最初の文字として指定する必要がある。
たとえば、@samp{[]a]}は、@samp{]}や@samp{a}に一致する。
@samp{-}を含めるのであれば、@samp{-}を文字集合の最初の文字か
最後の文字として指定して、範囲指定のあとに置く。
したがって、@samp{[]-]}は、@samp{]}と@samp{-}の両方に一致する。

@c To include @samp{^} in a set, put it anywhere but at the beginning of
@c the set.  (At the beginning, it complements the set---see below.)
文字集合に@samp{^}を含めるには、@samp{^}を文字集合の2番目以降に置く(最
初に置くと，それは集合に補足するようになる．以下を参照)。

@c When you use a range in case-insensitive search, you should write both
@c ends of the range in upper case, or both in lower case, or both should
@c be non-letters.  The behavior of a mixed-case range such as @samp{A-z}
@c is somewhat ill-defined, and it may change in future Emacs versions.
大文字小文字を区別する探索で文字範囲を指定するときは、
範囲の両端を、大文字だけ、小文字だけ、あるいは、
英字以外だけで書くべきである。
@samp{A-z}のような大文字小文字を混ぜた文字範囲の動作は、
定義が明確ではなく、将来のEmacsでは変更するかもしれない。

@item @kbd{[^ @dots{} ]}
@c @samp{[^} begins a @dfn{complemented character set}, which matches any
@c character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches
@c all characters @emph{except} @acronym{ASCII} letters and digits.
@samp{[^}は@dfn{文字の補集合}の始まりを意味し、
指定した文字を除く任意の文字に一致する。
すなわち、@samp{[^a-z0-9A-Z]}は、
@acronym{ASCII} 文字と数字を@emph{除く}すべての文字に一致する。

@c @samp{^} is not special in a character set unless it is the first
@c character.  The character following the @samp{^} is treated as if it
@c were first (in other words, @samp{-} and @samp{]} are not special there).
@samp{^}は先頭になければ文字集合では特別な意味を持たない。
@samp{^}に続く文字は先頭にあるものとして扱われる
（いいかえれば、ここでは@samp{-}や@samp{]}は特別な意味を持たない）。

@c A complemented character set can match a newline, unless newline is
@c mentioned as one of the characters not to match.  This is in contrast to
@c the handling of regexps in programs such as @code{grep}.
文字の補集合は、一致しない文字として改行を指定しない限り、改行にも一致する。
この点は、@code{grep}のようなプログラムでの正規表現の扱い方と対照的。

@item @kbd{^}
@c is a special character that matches the empty string, but only at the
@c beginning of a line in the text being matched.  Otherwise it fails to
@c match anything.  Thus, @samp{^foo} matches a @samp{foo} that occurs at
@c the beginning of a line.
空の文字列に一致する特別な文字で、テキスト行の先頭のみに一致する。
それ以外では、一致に失敗する。
したがって、@samp{^foo}は、行頭にある@samp{foo}に一致する。

@item @kbd{$}
@c is similar to @samp{^} but matches only at the end of a line.  Thus,
@c @samp{x+$} matches a string of one @samp{x} or more at the end of a line.
@samp{^}と似ていて、行末のみに一致する。
したがって、@samp{x+$}は、
行末にある1文字以上の@samp{x}から成る文字列に一致する。

@item @kbd{\}
@c has two functions: it quotes the special characters (including
@c @samp{\}), and it introduces additional special constructs.
2つの機能がある。
（@samp{\}を含む）特別な文字をクォートする（意味を抑える）ことと、
特別な構成を導入すること。

@c Because @samp{\} quotes special characters, @samp{\$} is a regular
@c expression that matches only @samp{$}, and @samp{\[} is a regular
@c expression that matches only @samp{[}, and so on.
@samp{\}は特別な文字をクォートするので、
@samp{\$}は文字@samp{$}だけに一致する正規表現、
@samp{\[}は文字@samp{[}だけに一致する正規表現、
というようになる。
@end table

@c Note: for historical compatibility, special characters are treated as
@c ordinary ones if they are in contexts where their special meanings make no
@c sense.  For example, @samp{*foo} treats @samp{*} as ordinary since there is
@c no preceding expression on which the @samp{*} can act.  It is poor practice
@c to depend on this behavior; it is better to quote the special character anyway,
@c regardless of where it appears.@refill
注意：@code{ }従来との互換性のために、特別な文字が、
それらの特別な意味をなしえない文脈で使われた場合には、
普通の文字として扱われます。
たとえば、@samp{*foo}では、@samp{*}の対象となる正規表現が直前にないため、
@samp{*}は普通の文字として扱われます。
このようなふるまいに依存することはよい習慣ではありません。
特別な文字を書く位置に関係なく特別な文字はクォートするべきです。

@c For the most part, @samp{\} followed by any character matches only that
@c character.  However, there are several exceptions: two-character
@c sequences starting with @samp{\} that have special meanings.  The second
@c character in the sequence is always an ordinary character when used on
@c its own.  Here is a table of @samp{\} constructs.
多くの場合、任意の文字を伴う@samp{\}はその文字だけに一致します。
しかし、いくつか例外があって、
@samp{\}で始まる2文字列が特別な意味を持つ場合があります。
2文字目にくる文字は、
単独で使った場合には普通の文字として扱われるものです。
以下に@samp{\}の構成を列挙します。

@table @kbd
@item \|
@c specifies an alternative.  Two regular expressions @var{a} and @var{b}
@c with @samp{\|} in between form an expression that matches some text if
@c either @var{a} matches it or @var{b} matches it.  It works by trying to
@c match @var{a}, and if that fails, by trying to match @var{b}.
選択肢を指定する。
@samp{\|}をあいだに伴った2つの正規表現@var{a}と@var{b}は、
@var{a}か@var{b}のいずれかに一致する文字列に一致する正規表現となる。

@c Thus, @samp{foo\|bar} matches either @samp{foo} or @samp{bar}
@c but no other string.@refill
したがって、@samp{foo\|bar}は、@samp{foo}か@samp{bar}に一致するが、
それ以外の文字列には一致しない。

@c @samp{\|} applies to the largest possible surrounding expressions.  Only a
@c surrounding @samp{\( @dots{} \)} grouping can limit the grouping power of
@c @samp{\|}.@refill
@samp{\|}は、周囲にある適用しうる正規表現の中でも最大のものに適用される。
@samp{\|}によるグループ化を制限するのは、
これを囲む@samp{\( @dots{} \)}によるグループ化だけ。

@c Full backtracking capability exists to handle multiple uses of @samp{\|}.
何度@samp{\|}を使っても処理できるだけの十分なバックトラック能力がある。

@item \( @dots{} \)
@c is a grouping construct that serves three purposes:
以下の3つの目的を果たすグループ化のための構成。

@enumerate
@item
@c To enclose a set of @samp{\|} alternatives for other operations.
@c Thus, @samp{\(foo\|bar\)x} matches either @samp{foox} or @samp{barx}.
他の操作に使うために一連の選択肢@samp{\|}を括る。
したがって、@samp{\(foo\|bar\)x}は、
@samp{foox}か@samp{barx}のいずれかに一致する。

@item
@c To enclose a complicated expression for the postfix operators @samp{*},
@c @samp{+} and @samp{?} to operate on.  Thus, @samp{ba\(na\)*} matches
@c @samp{bananana}, etc., with any (zero or more) number of @samp{na}
@c strings.@refill
後置演算子、@samp{*}、@samp{+}、@samp{?}を適用できるように、
複雑な正規表現を括る。
したがって、@samp{ba\(na\)*}は、
@samp{bananana}のように、（0個以上の）任意個の
文字列@samp{na}に一致する。

@item
@c To record a matched substring for future reference.
あとで参照できるように、一致した部分文字列を記録する。
@end enumerate

@c This last application is not a consequence of the idea of a
@c parenthetical grouping; it is a separate feature that is assigned as a
@c second meaning to the same @samp{\( @dots{} \)} construct.  In practice
@c there is usually no conflict between the two meanings; when there is
@c a conflict, you can use a ``shy'' group.
この最後の運用は括弧でグループ化することの結果ではない．これは @samp{\( @dots{}
\)}  の2番目の機能にすぎない．実際，これら2つの機能が衝突するようなことはない．
衝突するような時には"shy"グループ化を利用できる．

@item \(?: @dots{} \)
@cindex shy group, in regexp
@c specifies a ``shy'' group that does not record the matched substring;
@c you can't refer back to it with @samp{\@var{d}}.  This is useful
@c in mechanically combining regular expressions, so that you
@c can add groups for syntactic purposes without interfering with
@c the numbering of the groups that were written by the user.
は"shy"グループを定義し，一致文字を記録しない．つまり，@samp{\@var{d}} で参照す
ることはできません．この機能は正規表現を機械的にまとめる時に役立ちます．これによ
り，グループナンバに影響を与えることなくグループ化を行うことができるのです．

@item \@var{d}
@c matches the same text that matched the @var{d}th occurrence of a
@c @samp{\( @dots{} \)} construct.
@var{d}番目に現れた@samp{\( @dots{} \)}に一致したテキストと
同じテキストに一致する。

@c After the end of a @samp{\( @dots{} \)} construct, the matcher remembers
@c the beginning and end of the text matched by that construct.  Then,
@c later on in the regular expression, you can use @samp{\} followed by the
@c digit @var{d} to mean ``match the same text matched the @var{d}th time
@c by the @samp{\( @dots{} \)} construct.''
一致を処理するときには、@samp{\( @dots{} \)}構成の末尾に達すると、
この構成に一致したテキストの始めと終りを記録する。
そして、正規表現のそれよりうしろでは、
『@var{d}番目に現れた@samp{\( @dots{} \)}に一致したテキスト』という意味で
@samp{\}に続けて数字@var{d}を使える。

@c The strings matching the first nine @samp{\( @dots{} \)} constructs
@c appearing in a regular expression are assigned numbers 1 through 9 in
@c the order that the open-parentheses appear in the regular expression.
@c So you can use @samp{\1} through @samp{\9} to refer to the text matched
@c by the corresponding @samp{\( @dots{} \)} constructs.
1つの正規表現内に現れる最初の9個の@samp{\( @dots{} \)}に一致する文字列には、
正規表現中で開き括弧が現れた順に、1から9までの番号を割りふる。
そのため、@samp{\1}から@samp{\9}で、
対応する@samp{\( @dots{} \)}に一致したテキストを参照できる。

@c For example, @samp{\(.*\)\1} matches any newline-free string that is
@c composed of two identical halves.  The @samp{\(.*\)} matches the first
@c half, which may be anything, but the @samp{\1} that follows must match
@c the same exact text.
たとえば、@samp{\(.*\)\1}は、改行を含まない文字列で、かつ、
前半と後半が同一である文字列に一致する。
@samp{\(.*\)}は前半部分に一致し、それはどのようなものでもかまわない。
一方、それに続く@samp{\1}は、
前半部分とまったく同じテキストに一致しなければならない。

@c If a particular @samp{\( @dots{} \)} construct matches more than once
@c (which can easily happen if it is followed by @samp{*}), only the last
@c match is recorded.
ある@samp{\( @dots{} \)}が、
（直後に@samp{*}がある場合などに簡単に起こりえる）
複数回一致する場合には、最後に一致したものだけを記録する。

@item \`
@c matches the empty string, but only at the beginning of the string or
@c buffer (or its accessible portion) being matched against.
空の文字列に一致するが、
一致対象であるバッファや文字列(あるいは探索できる部分)の先頭に限る。

@item \'
@c matches the empty string, but only at the end of the string or buffer
@c (or its accessible portion) being matched against.
空の文字列に一致するが、
一致対象であるバッファや文字列(あるいは探索できる部分)の末尾に限る。

@item \=
@c matches the empty string, but only at point.
空の文字列に一致するが、ポイント位置に限る。

@item \b
@c matches the empty string, but only at the beginning or
@c end of a word.  Thus, @samp{\bfoo\b} matches any occurrence of
@c @samp{foo} as a separate word.  @samp{\bballs?\b} matches
@c @samp{ball} or @samp{balls} as a separate word.@refill
同じく空の文字列に一致するが、単語の先頭や末尾に限る。
したがって、@samp{\bfoo\b}は、単語として独立して現れる@samp{foo}に一致する。
@samp{\bballs?\b}は、単語として独立して現れる
@samp{ball}や@samp{balls}に一致する。

@c @samp{\b} matches at the beginning or end of the buffer
@c regardless of what text appears next to it.
@samp{\b}は、
バッファの先頭や末尾にあるテキストとは無関係に、
バッファの先頭や末尾にも一致する。

@item \B
@c matches the empty string, but @emph{not} at the beginning or
@c end of a word.
空の文字列に一致するが、単語の先頭や末尾@emph{以外}に限る。

@item \<
@c matches the empty string, but only at the beginning of a word.
@c @samp{\<} matches at the beginning of the buffer only if a
@c word-constituent character follows.
空の文字列に一致するが、単語の先頭に限る。
@samp{\<}は、単語構成文字が続く場合に限って、
バッファの先頭にも一致する。

@item \>
@c matches the empty string, but only at the end of a word.  @samp{\>}
@c matches at the end of the buffer only if the contents end with a
@c word-constituent character.
空の文字列に一致するが、単語の末尾に限る。
@samp{\>}は、単語構成文字で終了している場合に限って、
バッファの末尾にも一致する。

@item \w
@c matches any word-constituent character.  The syntax table
@c determines which characters these are.  @xref{Syntax}.
任意の単語構成文字に一致する。
エディタの構文テーブルによってこの文字が決まる。
@pxref{Syntax}。

@item \W
@c matches any character that is not a word-constituent.
単語構成文字以外の文字に一致する。

@item \s@var{c}
@c matches any character whose syntax is @var{c}.  Here @var{c} is a
@c character that designates a particular syntax class: thus, @samp{w}
@c for word constituent, @samp{-} or @samp{ } for whitespace, @samp{.}
@c for ordinary punctuation, etc.  @xref{Syntax}.
構文が@var{c}である文字だけに一致する。
ここで、@var{c}は構文クラスを表す文字。
たとえば、@samp{w}は単語構成要素を、
@samp{-} や@samp{ } は白文字を、@samp{.}は普通の句読点とった具合である．これにつ
いては，@xref{Syntax} を参照してください．

@item \S@var{c}
@c matches any character whose syntax is not @var{c}.
構文が@var{c}でない任意の文字に一致する。

@cindex categories of characters
@cindex characters which belong to a specific language
@findex describe-categories
@item \c@var{c}
matches any character that belongs to the category @var{c}.  For
example, @samp{\cc} matches Chinese characters, @samp{\cg} matches
Greek characters, etc.  For the description of the known categories,
type @kbd{M-x describe-categories @key{RET}}.

@item \C@var{c}
matches any character that does @emph{not} belong to category
@var{c}.
@end table

@c   The constructs that pertain to words and syntax are controlled by the
@c setting of the syntax table (@pxref{Syntax}).
単語や構文に関連する構成要素は、
構文テーブル（@pxref{Syntax}）の設定で制御されます。

@c   Here is a complicated regexp, stored in @code{sentence-end} and used
@c by Emacs to recognize the end of a sentence together with any
@c whitespace that follows.  We show its Lisp syntax to distinguish the
@c spaces from the tab characters.  In Lisp syntax, the string constant
@c begins and ends with a double-quote.  @samp{\"} stands for a
@c double-quote as part of the regexp, @samp{\\} for a backslash as part
@c of the regexp, @samp{\t} for a tab, and @samp{\n} for a newline.
複雑な正規表現を以下に示します。
これは、@code{sentence-end} に設定されるもので，任意個の白文字がうしろに続く文末を認識するためにEmacsが使うものです。
空白とタブ文字を区別できるように、Lispの構文で示してあります。
Lisp構文では、文字列定数はダブルクォートで始まり、
ダブルクォートで終ります。
@samp{\"}は正規表現の一部としてのダブルクォートを表し、
@samp{\\}は正規表現の一部としてのバックスラッシュを表します。
@samp{\t}はタブ文字、@samp{\n}は改行文字を表します。

@example
"[.?!][]\"')]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
@end example

@noindent
@c This contains four parts in succession: a character set matching
@c period, @samp{?}, or @samp{!}; a character set matching
@c close-brackets, quotes, or parentheses, repeated zero or more times; a
@c set of alternatives within backslash-parentheses that matches either
@c end-of-line, a space at the end of a line, a tab, or two spaces; and a
@c character set matching whitespace characters, repeated any number of
@c times.
この正規表現は4つの部分が繋がってできています。
ピリオド、@samp{?}、@samp{!}のいずれかに一致する文字集合。
閉じ中括、2種類の引用符、括弧に一致する文字集合の0回以上の繰り返し。
バックスラッシュ付きの括弧で括った、
行末、タブ、空白2つのいずれかに一致する選択肢。
白文字に一致する文字集合の任意回数の繰り返し。

@c   To enter the same regexp in incremental search, you would type
@c @key{TAB} to enter a tab, and @kbd{C-j} to enter a newline.  You would
@c also type single backslashes as themselves, instead of doubling them
@c for Lisp syntax.  In commands that use ordinary minibuffer input to
@c read a regexp, you would quote the @kbd{C-j} by preceding it with a
@c @kbd{C-q} to prevent @kbd{C-j} from exiting the minibuffer.
これと同じ正規表現をインクリメンタルサーチで入力するときには、タブを入力するには
@key{TAB}を打ち、改行を入力するには@kbd{C-j}を打ちます。また、Lisp構文上ではバッ
クスラッシュを2つ続けてますが、対話的に入力するには、1つのバックスラッシュだけを
打ちます。正規表現を入力するために普通のミニバッファを使うようなコマンドではミニ
バッファから@kbd{C-j}で抜けるのを避けるために@kbd{C-q}を先に入力する必要がありま
す．

@ignore
@c I commented this out because it is missing vital information
@c and therefore useless.  For instance, what do you do to *use* the
@c regular expression when it is finished?  What jobs is this good for?
@c  -- rms

@findex re-builder
@cindex authoring regular expressions
  For convenient interactive development of regular expressions, you
can use the @kbd{M-x re-builder} command.  It provides a convenient
interface for creating regular expressions, by giving immediate visual
feedback.  The buffer from which @code{re-builder} was invoked becomes
the target for the regexp editor, which pops in a separate window.  At
all times, all the matches in the target buffer for the current
regular expression are highlighted.  Each parenthesized sub-expression
of the regexp is shown in a distinct face, which makes it easier to
verify even very complex regexps.  (On displays that don't support
colors, Emacs blinks the cursor around the matched text, as it does
for matching parens.)
@end ignore

@node Search Case, Configuring Scrolling, Regexps, Search
@c @section Searching and Case
@section 探索と大文字小文字の区別

@c   Incremental searches in Emacs normally ignore the case of the text
@c they are searching through, if you specify the text in lower case.
@c Thus, if you specify searching for @samp{foo}, then @samp{Foo} and
@c @samp{foo} are also considered a match.  Regexps, and in particular
@c character sets, are included: @samp{[ab]} would match @samp{a} or
@c @samp{A} or @samp{b} or @samp{B}.@refill
Emacsのインクリメンタルサーチでは、小文字だけで探索文字列を指定すると、
探索対象のテキストの大文字小文字の違いを通常無視します。
したがって、@samp{foo}を探索するように指定すると、
@samp{Foo}にも@samp{foo}にも一致します。
正規表現、特に文字集合の場合でも同様です。
@samp{[ab]}は、@samp{a}、@samp{A}、@samp{b}、@samp{B}のいずれにも一致します。

@c   An upper-case letter anywhere in the incremental search string makes
@c the search case-sensitive.  Thus, searching for @samp{Foo} does not find
@c @samp{foo} or @samp{FOO}.  This applies to regular expression search as
@c well as to string search.  The effect ceases if you delete the
@c upper-case letter from the search string.
インクリメンタルサーチする探索文字列のどこかに大文字があると、
大文字小文字を区別して探索します。
したがって、@samp{Foo}の探索では、
@samp{foo}や@samp{FOO}をみつけだせません。
このことは、文字列の探索だけでなく正規表現の探索にもあてはまります。
探索文字列から大文字を消去すれば、この効果はなくなります。

@c   Typing @kbd{M-c} within an incremental search toggles the case
@c sensitivity of that search.  The effect does not extend beyond the
@c current incremental search to the next one, but it does override the
@c effect of including an upper-case letter in the current search.
インクリメンタルサーチで@kbd{M-c}を入力すると大文字小文字を区別するかどうかを切
り替えることができます．この効果はその時だけで次回には有効になりません．しかし，
現在の検索では大文字を含める効果になります．

@vindex case-fold-search
@c   If you set the variable @code{case-fold-search} to @code{nil}, then
@c all letters must match exactly, including case.  This is a per-buffer
@c variable; altering the variable affects only the current buffer, but
@c there is a default value which you can change as well.  @xref{Locals}.
@c This variable applies to nonincremental searches also, including those
@c performed by the replace commands (@pxref{Replace}) and the minibuffer
@c history matching commands (@pxref{Minibuffer History}).
変数@code{case-fold-search}に@code{nil}を設定すれば、
大文字小文字の違いを含めて、すべての文字はそのとおりに一致するようになります。
これは、バッファごとの変数です。
変数を変更してもカレントバッファだけに影響しますが、
変更可能なデフォルトの値があります。
@xref{Locals}。
この変数は、置換コマンド（@pxref{Replace}）や
ミニバッファの履歴探索コマンド（@pxref{Minibuffer History}）が
行う探索を含む、一括型探索にも適用されます。

@node Configuring Scrolling, Replace, Search Case, Search
@c @section Configuring Scrolling
@section スクロールの設定
@cindex scrolling in incremental search
@vindex isearch-allow-scroll

@c Scrolling, etc., during incremental search is enabled by setting the
@c customizable variable @code{isearch-allow-scroll} to a non-nil value.
@code{isearch-allow-scroll} を非nil 値に設定することで，インクリメンタルサーチ中
にスクロールなどを可能にすることができます．

@c See Subject: Info file:  How do I get an itemized list without blank lines?
@c Date: Sat, 12 Apr 2003 09:45:31 +0000  in gnu.emacs.help
@c @subsection Standard scrolling commands
@subsection 標準的なスクロールコマンド
@c Here is the list of commands which are configured by default to be
@c ``scrolling'' commands in an incremental search, together with their
@c usual bindings:
以下はインクリメンタルサーチ中に実行できる"スクロール"コマンドと通常のキーバイン
ドのリストです．

@c @subsubsection Commands which scroll the window:
@subsubsection ウィンドウをスクロールするコマンド
@table @asis
@item @code{scroll-bar-toolkit-scroll} (@kbd{@key{vertical-scroll-bar}@key{mouse-1}} in X-Windows)
@itemx @code{mac-handle-scroll-bar-event} (@kbd{@key{vertical-scroll-bar}@key{mouse-1}} on a Mac)
@itemx @code{w32-handle-scroll-bar-event} (@kbd{@key{vertical-scroll-bar}@key{mouse-1}} in MS-Windows)
@item @code{recenter} (@kbd{C-l}) @xref{Scrolling}.
@itemx @code{reposition-window} (@kbd{C-M-l}) @xref{Scrolling}.
@itemx @code{scroll-up} (@kbd{@key{NEXT}}) @xref{Scrolling}.
@itemx @code{scroll-down} (@kbd{@key{PRIOR}}) @xref{Scrolling}.
@end table

@c @subsubsection Commands which act on the other window:
@subsubsection 他のウィンドウで機能するコマンド
@table @asis
@item @code{list-buffers} (@kbd{C-x C-b}) @xref{List Buffers}.
@itemx @code{scroll-other-window} (@kbd{C-M-v}) @xref{Other Window}.
@itemx @code{scroll-other-window-down} (@kbd{C-M-S-v}) @xref{Other Window}.
@itemx @code{beginning-of-buffer-other-window} (@kbd{M-@key{home}})
@itemx @code{end-of-buffer-other-window} (@kbd{M-@key{end}})
@end table

@c @subsubsection Commands which change the window layout:
@subsubsection ウィンドウレイアウトを変更するコマンド
@table @asis
@item @code{delete-other-windows} (@kbd{C-x 1}) @xref{Change Window}.
@itemx @code{balance-windows} (@kbd{C-x +}) @xref{Change Window}.
@itemx @code{split-window-vertically} (@kbd{C-x 2}) @xref{Split Window}.
@itemx @code{enlarge-window} (@kbd{C-x ^}) @xref{Change Window}.
@end table

@c @subsection Configuring other commands as scrolling commands
@subsection 他のコマンドをスクロールコマンドとして設定
@c To do this, set a command's isearch-scroll property to the value t.
@c For example:
設定するためにはコマンドの isearch-scroll プロパティを t にします．例えば，以下
のようにします．

@example
@code{(put 'my-command 'isearch-scroll t)}
@end example

@c You should only thus configure commands which are ``safe'': i.e., they
@c won't leave emacs in an inconsistent state when executed within a
@c search - that is to say, the following things may be changed by a
@c command only temporarily, and must be restored before the command
@c finishes:
ただし，"安全"なコマンドだけを設定すべきです．つまり，検索中に実行された時に矛盾
するような状態にしないようにします．すなわち，続くものを一時的に変更するようなコ
マンドはコマンドを終える前に保存しなければなりません．

@enumerate
@item
@c Point.
ポイント
@item
@c The buffer contents.
バッファの内容
@item
@c The selected window and selected frame.
選択されたウィンドウやフレーム
@item
@c The current match-data @xref{Match Data,,,elisp}.
現在の一致データ (@xref{Match Data,,,elisp})
@end enumerate

@c Additionally, the command must not delete the current window and must
@c not itself attempt an incremental search.  It may, however, change the
@c window's size, or create or delete other windows and frames.
さらに，現在のウィンドウを消してはならないし，コマンド自身がインクリメンタルサー
チを実行してはなりません．しかし，ウィンドウのサイズ変更や他のウィンドウやフレー
ムを作ったり消したりすることは可能です．

@c Note that an attempt by a command to scroll the text
@c @emph{horizontally} won't work, although it will do no harm - any such
@c scrolling will be overriden and nullified by the display code.
テキストを@emph{水平方向}にスクロールさせるコマンドは害を与えませんが，動作しま
せん．そのようなスクロールは無効になります．

@node Replace, Other Repeating Search, Configuring Scrolling, Search
@c @section Replacement Commands
@section 置換コマンド @emph{(2004/03/27)}
@c @cindex replacement
@c @cindex search-and-replace commands
@c @cindex string substitution
@c @cindex global substitution
@cindex 置換
@cindex 探索置換コマンド
@cindex 文字列置換
@cindex 大域的な置換

@c   Global search-and-replace operations are not needed often in Emacs,
@c but they are available.  In addition to the simple @kbd{M-x
@c replace-string} command which is like that found in most editors,
@c there is a @kbd{M-x query-replace} command which finds each occurrence
@c of the pattern and asks you whether to replace it.
大域的な探索置換操作は、
Emacsではそれほど必要性がありませんが、Emacsでも使えます。
多くのエディタにあるような単純なコマンド@kbd{M-x replace-string}の他にも、
パターンの各出現ごとに置換するかどうか尋ねてくる
@kbd{M-x query-replace}コマンドがあります。

@c   The replace commands normally operate on the text from point to the
@c end of the buffer; however, in Transient Mark mode (@pxref{Transient
@c Mark}), when the mark is active, they operate on the region.  The
@c replace commands all replace one string (or regexp) with one
@c replacement string.  It is possible to perform several replacements in
@c parallel using the command @code{expand-region-abbrevs}
@c (@pxref{Expanding Abbrevs}).
置換コマンドは、通常、ポイントからバッファの末尾までのテキストを操作します。
しかし、暫定マーク（transient-mark，@pxref{Transient Mark}）モードでは、
マークが活性である場合にはリージョンを操作します。
置換コマンドはどれも、
1つの文字列（や正規表現）を1つの置換文字列に置き換えます。
コマンド@code{expand-region-abbrevs}（@pxref{Expanding Abbrevs}）を使って、
いくつかの置き換えを並行に行うことができます。

@menu
* Unconditional Replace::	Replacing all matches for a string.
* Regexp Replace::		Replacing all matches for a regexp.
* Replacement and Case::	How replacements preserve case of letters.
* Query Replace::		How to use querying.
@end menu

@node Unconditional Replace, Regexp Replace, Replace, Replace
@c @subsection Unconditional Replacement
@subsection 無条件置換 @emph{(2004/03/27)}
@findex replace-string
@findex replace-regexp

@table @kbd
@item M-x replace-string @key{RET} @var{string} @key{RET} @var{newstring} @key{RET}
@c Replace every occurrence of @var{string} with @var{newstring}.
@var{string}のすべての出現を@var{newstring}で置換する。
@item M-x replace-regexp @key{RET} @var{regexp} @key{RET} @var{newstring} @key{RET}
@c Replace every match for @var{regexp} with @var{newstring}.
正規表現@var{regexp}に一致するものすべてを@var{newstring}で置換する。
@end table

@c   To replace every instance of @samp{foo} after point with @samp{bar},
@c use the command @kbd{M-x replace-string} with the two arguments
@c @samp{foo} and @samp{bar}.  Replacement happens only in the text after
@c point, so if you want to cover the whole buffer you must go to the
@c beginning first.  All occurrences up to the end of the buffer are
@c replaced; to limit replacement to part of the buffer, narrow to that
@c part of the buffer before doing the replacement (@pxref{Narrowing}).
@c In Transient Mark mode, when the region is active, replacement is
@c limited to the region (@pxref{Transient Mark}).
ポイント以降にある@samp{foo}のすべての出現を
@samp{bar}で置き換えるには、2つの引数@samp{foo}と@samp{bar}を指定した
コマンド@kbd{M-x replace-string}を使います。
置換はポイント以降でのみ実施されますから、
バッファ全体に対して置換を行いたいときには、
まずバッファの先頭に移動しておく必要があります。
バッファの末尾までに現れるすべての出現を置換します。
バッファの一部に置換を限定したいときには、
置換を実行するまえに、バッファの当該部分にナロイングしておきます
（@pxref{Narrowing}）。
暫定マーク（transient-mark）モードにおいては、
リージョンが活性のときには、置換はリージョン内に限定されます。

@c   When @code{replace-string} exits, it leaves point at the last
@c occurrence replaced.  It sets the mark to the prior position of point
@c (where the @code{replace-string} command was issued); use @kbd{C-u
@c C-@key{SPC}} to move back there.
@code{replace-string}を終了すると、
ポイントは最後に置換した出現箇所に置かれます。
マークは（@code{replace-string}コマンドを起動したとき）
以前のポイント位置に設定されます。
その位置に戻るには@kbd{C-u C-@key{SPC}}を使います。

@c   A numeric argument restricts replacement to matches that are surrounded
@c by word boundaries.  The argument's value doesn't matter.
数引数を指定すると、
単語区切りで囲まれた出現だけを置換対象とします。
引数の値は関係ありません。

@c   What if you want to exchange @samp{x} and @samp{y}: replace every @samp{x} with a @samp{y} and vice versa?  You can do it this way:
@samp{x} と @samp{y}を交換したければ，すべての@samp{x} を @samp{y} で置換しなけ
ればならないか？逆の場合も？これは以下のようにできます．

@example
M-x query-replace @key{RET} x @key{RET} @@TEMP@@ @key{RET}
M-x query-replace @key{RET} y @key{RET} x @key{RET}
M-x query-replace @key{RET} @@TEMP@@ @key{RET} y @key{RET}
@end example

@noindent
@c This works provided the string @samp{@@TEMP@@} does not appear
@c in your text.
@samp{@@TEMP@@} という元の文章にはない文字があり，その文字が機能している．

@node Regexp Replace, Replacement and Case, Unconditional Replace, Replace
@c @subsection Regexp Replacement
@subsection 正規表現による置換

@c   The @kbd{M-x replace-string} command replaces exact matches for a
@c single string.  The similar command @kbd{M-x replace-regexp} replaces
@c any match for a specified pattern.
@kbd{M-x replace-string}コマンドは、
1つの文字列に正確に一致するものだけを置き換えます。
これに類似したコマンド@kbd{M-x replace-regexp}は、
指定したパターンに一致する任意のものを置き換えます。

@c   In @code{replace-regexp}, the @var{newstring} need not be constant: it
@c can refer to all or part of what is matched by the @var{regexp}.
@c @samp{\&} in @var{newstring} stands for the entire match being replaced.
@c @samp{\@var{d}} in @var{newstring}, where @var{d} is a digit, stands for
@c whatever matched the @var{d}th parenthesized grouping in @var{regexp}.
@c To include a @samp{\} in the text to replace with, you must enter
@c @samp{\\}.  For example,
@code{replace-regexp}では、
@var{newstring}が定数である必要はありません。
@var{regexp}に一致したものの全体あるいはその一部を参照できます。
@var{newstring}の中の@samp{\&}は、
置換対象の文字列全体（つまり、@var{regexp}に一致したものの全体）を
表します。
@var{newstring}の中の@samp{\@var{d}}（@var{d}は数字）は、
@var{regexp}の中の@var{d}番目の括弧のグループ化部分に
一致した部分を表します。
置き換えるテキスト内に@samp{\}を含めるには、
@samp{\\}と入力する必要があります。

@example
M-x replace-regexp @key{RET} c[ad]+r @key{RET} \&-safe @key{RET}
@end example

@noindent
@c replaces (for example) @samp{cadr} with @samp{cadr-safe} and @samp{cddr}
@c with @samp{cddr-safe}.
たとえばこの例は、@samp{cadr}を@samp{cadr-safe}で、
@samp{cddr}を@samp{cddr-safe}で置換します。

@example
M-x replace-regexp @key{RET} \(c[ad]+r\)-safe @key{RET} \1 @key{RET}
@end example

@noindent
@c performs the inverse transformation.
この例は、逆の置換を行います。

@node Replacement and Case, Query Replace, Regexp Replace, Replace
@c @subsection Replace Commands and Case
@subsection 置換コマンドと大文字小文字の区別 @emph{(2004/03/27)}

@c   If the first argument of a replace command is all lower case, the
@c command ignores case while searching for occurrences to
@c replace---provided @code{case-fold-search} is non-@code{nil}.  If
@c @code{case-fold-search} is set to @code{nil}, case is always significant
@c in all searches.
置換コマンドの第1引数がすべて小文字である場合、
@code{case-fold-search}が@code{nil}以外であるときには、
大文字小文字を区別せずに置換対象を探索します。
@code{case-fold-search}が@code{nil}であるときには、
すべての探索において大文字小文字を区別します。

@vindex case-replace
@c   In addition, when the @var{newstring} argument is all or partly lower
@c case, replacement commands try to preserve the case pattern of each
@c occurrence.  Thus, the command
さらに、引数@var{newstring}が、すべて小文字、あるいは、
一部が小文字のときには、置換コマンドは、
各置換対象の大文字小文字のパターンを保存しようとします。
つまり、コマンド

@example
M-x replace-string @key{RET} foo @key{RET} bar @key{RET}
@end example

@noindent
@c replaces a lower case @samp{foo} with a lower case @samp{bar}, an
@c all-caps @samp{FOO} with @samp{BAR}, and a capitalized @samp{Foo} with
@c @samp{Bar}.  (These three alternatives---lower case, all caps, and
@c capitalized, are the only ones that @code{replace-string} can
@c distinguish.)
は、小文字の@samp{foo}を小文字の@samp{bar}に、
すべて大文字の@samp{FOO}を@samp{BAR}に、
大文字で始まる@samp{Foo}を@samp{Bar}に置換します。
（@code{replace-string}が区別できるのは、これら3つの選択肢、
つまり、小文字のみ、すべて大文字、大文字で始まるだけ。）

@c   If upper-case letters are used in the replacement string, they remain
@c upper case every time that text is inserted.  If upper-case letters are
@c used in the first argument, the second argument is always substituted
@c exactly as given, with no case conversion.  Likewise, if either
@c @code{case-replace} or @code{case-fold-search} is set to @code{nil},
@c replacement is done without case conversion.
置換文字列に大文字を使ったときには、
これを挿入するときは大文字は大文字のままです。
第1引数に大文字を使ったときには、
第2引数では大文字小文字を変換せずにつねに指定どおりに置き換えます。
同様に、@code{case-replace}や@code{case-fold-search}に
@code{nil}を設定すると、
大文字小文字を変換せずに置換します。

@node Query Replace,, Replacement and Case, Replace
@c @subsection Query Replace
@subsection 問い合わせ型置換 @emph{(2004/03/27)}
@c @cindex query replace
@cindex 問い合わせ型置換

@table @kbd
@item M-% @var{string} @key{RET} @var{newstring} @key{RET}
@itemx M-x query-replace @key{RET} @var{string} @key{RET} @var{newstring} @key{RET}
@c Replace some occurrences of @var{string} with @var{newstring}.
@var{string}のいくつかの出現を@var{newstring}で置換する。
@item C-M-% @var{regexp} @key{RET} @var{newstring} @key{RET}
@itemx M-x query-replace-regexp @key{RET} @var{regexp} @key{RET} @var{newstring} @key{RET}
@c Replace some matches for @var{regexp} with @var{newstring}.
正規表現@var{regexp}に一致するもののいくつかを@var{newstring}で置換する。
@end table

@kindex M-%
@findex query-replace
@c   If you want to change only some of the occurrences of @samp{foo} to
@c @samp{bar}, not all of them, then you cannot use an ordinary
@c @code{replace-string}.  Instead, use @kbd{M-%} (@code{query-replace}).
@c This command finds occurrences of @samp{foo} one by one, displays each
@c occurrence and asks you whether to replace it.  Aside from querying,
@c @code{query-replace} works just like @code{replace-string}.  It
@c preserves case, like @code{replace-string}, provided
@c @code{case-replace} is non-@code{nil}, as it normally is.  A numeric
@c argument means consider only occurrences that are bounded by
@c word-delimiter characters.
@samp{foo}のすべての出現ではなく、
そのうちのいくつかだけを@samp{bar}に変更したいときには、
通常の@code{replace-string}を使うことはできません。
かわりに、@kbd{M-%}（@code{query-replace}）を使います。
このコマンドは@samp{foo}の出現をみつけるたびに、
その出現を表示し、置換するかどうか聞いてきます。質問する以外は
@code{query-replace} は @code{replace-string} のように機能します．
通常どおり@code{case-replace}が@code{nil}以外であれば、
@code{replace-string}と同じく、
このコマンドも大文字小文字の違いを保存します。@code{query-replace}に数引数を指定すると、
単語区切り文字で区切られた出現だけを対象とします。


@kindex C-M-%
@findex query-replace-regexp
@c   @kbd{C-M-%} performs regexp search and replace (@code{query-replace-regexp}).
@kbd{C-M-%} は正規表現を検索し置換します (@code{query-replace-regexp})．

@c   The characters you can type when you are shown a match for the string
@c or regexp are:
文字の出現や正規表現に一致したものが表示されたときに打てる文字はつぎのとおりです。

@ignore @c Not worth it.
@kindex SPC @r{(query-replace)}
@kindex DEL @r{(query-replace)}
@kindex , @r{(query-replace)}
@kindex RET @r{(query-replace)}
@kindex . @r{(query-replace)}
@kindex ! @r{(query-replace)}
@kindex ^ @r{(query-replace)}
@kindex C-r @r{(query-replace)}
@kindex C-w @r{(query-replace)}
@kindex C-l @r{(query-replace)}
@end ignore

@c WideCommands
@table @kbd
@item @key{SPC}
@c to replace the occurrence with @var{newstring}.
出現を@var{newstring}で置換する。

@item @key{DEL}
@c to skip to the next occurrence without replacing this one.
この出現を置換せずにつぎの出現箇所に進む。

@c @item , @r{(Comma)}
@item , @r{（カンマ）}
@c to replace this occurrence and display the result.  You are then asked
@c for another input character to say what to do next.  Since the
@c replacement has already been made, @key{DEL} and @key{SPC} are
@c equivalent in this situation; both move to the next occurrence.
この出現を置換し、結果を表示する。
そして、つぎに何をするか指示する文字を聞いてくる。
置換自体はすでに完了しているので、
この状況では@key{DEL}と@key{SPC}は等価であり、
つぎの出現箇所へ移動するという意味。

@c You can type @kbd{C-r} at this point (see below) to alter the replaced
@c text.  You can also type @kbd{C-x u} to undo the replacement; this exits
@c the @code{query-replace}, so if you want to do further replacement you
@c must use @kbd{C-x @key{ESC} @key{ESC} @key{RET}} to restart
@c (@pxref{Repetition}).
この時点では、@kbd{C-r}（下記参照）を打って、置換したテキストを変更できる。
また、@kbd{C-x u}と打って、置換をアンドゥする（もとに戻す）こともできるが、
そうすると、@code{query-replace}を終了してしまう。
さらに先の置換を行いたいときには、
@kbd{C-x @key{ESC} @key{ESC} @key{RET}}を使って再開する必要がある
（@pxref{Repetition}）。

@item @key{RET}
@c to exit without doing any more replacements.
これ以上何も置換しないで終了する。

@c @item .@: @r{(Period)}
@item .@: @r{（ピリオド）}
@c to replace this occurrence and then exit without searching for more
@c occurrences.
この出現を置換してから、これ以上探索せずに終了する。

@item !
@c to replace all remaining occurrences without asking again.
これ以降、問い合わせずに残りの出現すべてを置換する。

@item ^
@c to go back to the position of the previous occurrence (or what used to
@c be an occurrence), in case you changed it by mistake.  This works by
@c popping the mark ring.  Only one @kbd{^} in a row is meaningful, because
@c only one previous replacement position is kept during @code{query-replace}.
誤って変更してしまった場合などに、
1つまえの出現箇所（あるいは置換してしまった出現箇所）に戻る。
これは、マークリングから位置を取り出して動作する。
@code{query-replace}は直前の1つの置換位置だけを記録するため、
@kbd{^}を続けて入力しても意味はない。

@item C-r
@c to enter a recursive editing level, in case the occurrence needs to be
@c edited rather than just replaced with @var{newstring}.  When you are
@c done, exit the recursive editing level with @kbd{C-M-c} to proceed to
@c the next occurrence.  @xref{Recursive Edit}.
単に@var{newstring}で置換するだけでなく、
この出現を編集する必要がある場合などに、再帰編集レベルに入る。
編集し終えて@kbd{C-M-c}で再帰編集を抜けると、つぎの出現箇所に移動する。
@pxref{Recursive Edit}。

@item C-w
@c to delete the occurrence, and then enter a recursive editing level as in
@c @kbd{C-r}.  Use the recursive edit to insert text to replace the deleted
@c occurrence of @var{string}.  When done, exit the recursive editing level
@c with @kbd{C-M-c} to proceed to the next occurrence.
出現を削除してから、@kbd{C-r}と同様に再帰編集レベルに入る。
再帰編集を使って、削除した@var{string}の出現を置き換えるテキストを挿入する。
編集し終えて@kbd{C-M-c}で再帰編集を抜けると、つぎの出現箇所に移動する。

@item e
@c to edit the replacement string in the minibuffer.  When you exit the
@c minibuffer by typing @key{RET}, the minibuffer contents replace the
@c current occurrence of the pattern.  They also become the new
@c replacement string for any further occurrences.
ミニバッファで置換する文字を編集する．ミニバッファから @key{RET} で抜けるとミニ
バッファの内容で現在の一致箇所を置換する．続く一致箇所でも新しい文字で置換されま
す．

@item C-l
@c to redisplay the screen.  Then you must type another character to
@c specify what to do with this occurrence.
画面を再表示する。
そうしたら、この出現に対して何を行うかを指示する別の文字を打つ必要がある。

@item C-h
@c to display a message summarizing these options.  Then you must type
@c another character to specify what to do with this occurrence.
これらのオプションの要約メッセージを表示する。
そうしたら、この出現に対して何を行うかを指示する別の文字を打つ必要がある。
@end table

@c   Some other characters are aliases for the ones listed above: @kbd{y},
@c @kbd{n} and @kbd{q} are equivalent to @key{SPC}, @key{DEL} and
@c @key{RET}.
上記のコマンドの別名である文字が他にもいくつかあります。
@kbd{y}、@kbd{n}、@kbd{q}は、それぞれ、
@key{SPC}、@key{DEL}、@key{RET}に等価です。

@c   Aside from this, any other character exits the @code{query-replace},
@c and is then reread as part of a key sequence.  Thus, if you type
@c @kbd{C-k}, it exits the @code{query-replace} and then kills to end of
@c line.
これ以外の文字は@code{query-replace}を終了し、
その文字はキー列の一部になります。
したがって、@kbd{C-k}と打つと、
@code{query-replace}を終了してから、行末までをキルします。

@c   To restart a @code{query-replace} once it is exited, use @kbd{C-x
@c @key{ESC} @key{ESC}}, which repeats the @code{query-replace} because it
@c used the minibuffer to read its arguments.  @xref{Repetition, C-x ESC
@c ESC}.
一度抜けた@code{query-replace}を再開するには、
@kbd{C-x @key{ESC} @key{ESC}}を使います。
このコマンドは@code{query-replace}を繰り返します。
というのは、@code{query-replace}はミニバッファで引数を読み取るからです。
@xref{Repetition, C-x ESC ESC}。

@c   See also @ref{Transforming File Names}, for Dired commands to rename,
@c copy, or link files by replacing regexp matches in file names.
ファイル名に対して正規表現に一致する部分を置換することで、
ファイルの改名、コピー、リンクを行うdiredコマンドについては、
@ref{Transforming File Names}も参照してください。

@node Other Repeating Search,, Replace, Search
@c @section Other Search-and-Loop Commands
@section 他の探索繰り返しコマンド @emph{(2004/03/27)}

@c   Here are some other commands that find matches for a regular
@c expression.  They all ignore case in matching, if the pattern contains
@c no upper-case letters and @code{case-fold-search} is non-@code{nil}.
@c Aside from @code{occur} and its variants, all operate on the text from
@c point to the end of the buffer, or on the active region in Transient
@c Mark mode.
正規表現に一致するものをみつけるコマンドは、他にもいくつかあります。
それらは、パターンに大文字が含まれていないときや、
@code{case-fold-search}が@code{nil}以外であるときには、
大文字小文字の違いを無視して一致を探します。@code{occur} や同種のコマンドを除く
と，ポイント位置からバッファの末尾までか暫定マークモード(Transient Mark mode) で
アクティブなリージョンを操作対象とします．


@findex list-matching-lines
@findex occur
@findex multi-occur
@findex multi-occur-by-filename-regexp
@findex how-many
@findex delete-non-matching-lines
@findex delete-matching-lines
@findex flush-lines
@findex keep-lines

@table @kbd
@item M-x occur @key{RET} @var{regexp} @key{RET}
@c Display a list showing each line in the buffer that contains a match
@c for @var{regexp}.  To limit the search to part of the buffer, narrow
@c to that part (@pxref{Narrowing}).  A numeric argument @var{n}
@c specifies that @var{n} lines of context are to be displayed before and
@c after each matching line.
@var{regexp}に一致するものを含むバッファ内の各行の一覧を表示する。
バッファの一部に探索を制限するには、その部分にナロイングする（@pxref{Narrowing}）。
数引数 @var{n}で、一致した各行の前後@var{n}行を表示するように指定できる．

@kindex RET @r{(Occur mode)}
@kindex o @r{(Occur mode)}
@kindex C-o @r{(Occur mode)}
@c The buffer @samp{*Occur*} containing the output serves as a menu for
@c finding the occurrences in their original context.  Click
@c @kbd{Mouse-2} on an occurrence listed in @samp{*Occur*}, or position
@c point there and type @key{RET}; this switches to the buffer that was
@c searched and moves point to the original of the chosen occurrence.
@c @kbd{o} and @kbd{C-o} display the match in another window; @kbd{C-o}
@c does not select it.
出力を表示したバッファ@samp{*Occur*}は、
もとの文脈での出現位置を探すためのメニューとして機能する。
@samp{*Occur*}に表示された出現を@kbd{Mouse-2}でクリックするか、あるいは、
ポイントをそこに置いて@key{RET}を打つ。
この操作により、探索を行ったバッファに切り替え、
選択した出現のもとの位置にポイントを移動する。@kbd{o} や @kbd{C-o} は一致箇所を
別ウィンドウに表示します．ただし，@kbd{C-o} は選択はしません．

@item M-x list-matching-lines
@c Synonym for @kbd{M-x occur}.
@kbd{M-x occur}と同じ。

@item M-x multi-occur @key{RET} @var{buffers} @key{RET} @var{regexp} @key{RET}
@c This function is just like @code{occur}, except it is able to search
@c through multiple buffers.
この関数は複数のバッファを検索できることを除けば，@code{occur} と同様のものであ
る．

@item M-x multi-occur-by-filename-regexp @key{RET} @var{bufregexp} @key{RET} @var{regexp} @key{RET}
@c This function is similar to @code{multi-occur}, except the buffers to
@c search are specified by a regexp on their filename.
この関数は @code{multi-occur} と同様のものである．ただ，検索するバッファをそのファ
イル名に対する正規表現で指定できる．

@item M-x how-many @key{RET} @var{regexp} @key{RET}
@c Print the number of matches for @var{regexp} that exist in the buffer
@c after point.  In Transient Mark mode, if the region is active, the
@c command operates on the region instead.
ポイント以降で@var{regexp}に一致するものの個数を表示する。暫定マークモード
(Transient Mark mode)ではリージョンが有効であれば，このコマンドはリージョン内だ
けを対象に動作する．

@item M-x flush-lines @key{RET} @var{regexp} @key{RET}
@c Delete each line that contains a match for @var{regexp}, operating on
@c the text after point.  In Transient Mark mode, if the region is
@c active, the command operates on the region instead.
ポイント以降にあって@var{regexp}に一致するものを含む各行を削除する。暫定マークモード
(Transient Mark mode)ではリージョンが有効であれば，このコマンドはリージョン内だ
けを対象に動作する．

@item M-x keep-lines @key{RET} @var{regexp} @key{RET}
@c Delete each line that @emph{does not} contain a match for
@c @var{regexp}, operating on the text after point.  In Transient Mark
@c mode, if the region is active, the command operates on the region
@c instead.
ポイント以降にあって@var{regexp}に一致するものを
含ま@emph{ない}各行を削除する。暫定マークモード
(Transient Mark mode)ではリージョンが有効であれば，このコマンドはリージョン内だ
けを対象に動作する．
@end table

@c   You can also search multiple files under control of a tags table
@c (@pxref{Tags Search}) or through Dired @kbd{A} command
@c (@pxref{Operating on Files}), or ask the @code{grep} program to do it
@c (@pxref{Grep Searching}).
タグテーブル (@pxref{Tags Search}) で複数のファイルを検索することができます．ある
いはDired で @kbd{A} (@pxref{Operating on Files}) を入力したり，@code{grep}
(@pxref{Grep Searching}) を利用しても複数のファイルを検索できます．

@ignore
   arch-tag: fd9d8e77-66af-491c-b212-d80999613e3e
@end ignore
